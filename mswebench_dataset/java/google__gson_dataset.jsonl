{"org": "google", "repo": "gson", "number": 1787, "state": "closed", "title": "Fix TypeAdapterRuntimeTypeWrapper not detecting reflective TreeTypeAdapter and FutureTypeAdapter", "body": "Fixes #543\r\nFixes #2032\r\nFixes #1833\r\n\r\nPreviously on serialization TypeAdapterRuntimeTypeWrapper preferred a TreeTypeAdapter without `serializer` which falls back to the reflective adapter.\r\nThis behavior was incorrect because it caused the reflective adapter for a Base class to be used for serialization (indirectly as TreeTypeAdapter delegate) instead of using the reflective adapter for a Subclass extending Base.", "base": {"label": "google:master", "ref": "master", "sha": "e614e71ee43ca7bc1cb466bd1eaf4d85499900d9"}, "resolved_issues": [{"number": 1833, "title": "TypeAdapterRuntimeTypeWrapper prefers cyclic adapter for base type over reflective adapter for sub type", "body": "The internal class `TypeAdapterRuntimeTypeWrapper` is supposed to prefer custom adapters for the compile type over the reflective adapter for the runtime type. However, when the compile type and the runtime type only have a reflective adapter, then it should prefer the runtime type adapter.\r\n\r\nThe problem is that this logic is not working for classes with cyclic dependencies which therefore have a `Gson$FutureTypeAdapter` wrapping a reflective adapter because the following line does not consider this:\r\nhttps://github.com/google/gson/blob/ceae88bd6667f4263bbe02e6b3710b8a683906a2/gson/src/main/java/com/google/gson/internal/bind/TypeAdapterRuntimeTypeWrapper.java#L60\r\n\r\nFor example:\r\n```java\r\nclass Base {\r\n  public Base f;\r\n}\r\n\r\nclass Sub extends Base {\r\n  public int i;\r\n\r\n  public Sub(int i) {\r\n    this.i = i;\r\n  }\r\n}\r\n```\r\n```java\r\nBase b = new Base();\r\nb.f = new Sub(2);\r\nString json = new Gson().toJson(b);\r\n// Fails because reflective adapter for base class is used, therefore json is: {\"f\":{}}\r\nassertEquals(\"{\\\"f\\\":{\\\"i\\\":2}}\", json);\r\n```\r\n\r\nNote: This is similar to the problem #1787 tries to fix for `TreeTypeAdapter`."}], "fix_patch": "diff --git a/gson/src/main/java/com/google/gson/Gson.java b/gson/src/main/java/com/google/gson/Gson.java\nindex bb3e2c7704..22071a17d8 100644\n--- a/gson/src/main/java/com/google/gson/Gson.java\n+++ b/gson/src/main/java/com/google/gson/Gson.java\n@@ -32,6 +32,7 @@\n import com.google.gson.internal.bind.NumberTypeAdapter;\n import com.google.gson.internal.bind.ObjectTypeAdapter;\n import com.google.gson.internal.bind.ReflectiveTypeAdapterFactory;\n+import com.google.gson.internal.bind.SerializationDelegatingTypeAdapter;\n import com.google.gson.internal.bind.TypeAdapters;\n import com.google.gson.internal.sql.SqlTypesSupport;\n import com.google.gson.reflect.TypeToken;\n@@ -1315,7 +1316,7 @@ public <T> T fromJson(JsonElement json, TypeToken<T> typeOfT) throws JsonSyntaxE\n     return fromJson(new JsonTreeReader(json), typeOfT);\n   }\n \n-  static class FutureTypeAdapter<T> extends TypeAdapter<T> {\n+  static class FutureTypeAdapter<T> extends SerializationDelegatingTypeAdapter<T> {\n     private TypeAdapter<T> delegate;\n \n     public void setDelegate(TypeAdapter<T> typeAdapter) {\n@@ -1325,18 +1326,23 @@ public void setDelegate(TypeAdapter<T> typeAdapter) {\n       delegate = typeAdapter;\n     }\n \n-    @Override public T read(JsonReader in) throws IOException {\n+    private TypeAdapter<T> delegate() {\n       if (delegate == null) {\n-        throw new IllegalStateException();\n+        throw new IllegalStateException(\"Delegate has not been set yet\");\n       }\n-      return delegate.read(in);\n+      return delegate;\n+    }\n+\n+    @Override public TypeAdapter<T> getSerializationDelegate() {\n+      return delegate();\n+    }\n+\n+    @Override public T read(JsonReader in) throws IOException {\n+      return delegate().read(in);\n     }\n \n     @Override public void write(JsonWriter out, T value) throws IOException {\n-      if (delegate == null) {\n-        throw new IllegalStateException();\n-      }\n-      delegate.write(out, value);\n+      delegate().write(out, value);\n     }\n   }\n \ndiff --git a/gson/src/main/java/com/google/gson/internal/bind/SerializationDelegatingTypeAdapter.java b/gson/src/main/java/com/google/gson/internal/bind/SerializationDelegatingTypeAdapter.java\nnew file mode 100644\nindex 0000000000..dad4ff1120\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/internal/bind/SerializationDelegatingTypeAdapter.java\n@@ -0,0 +1,14 @@\n+package com.google.gson.internal.bind;\n+\n+import com.google.gson.TypeAdapter;\n+\n+/**\n+ * Type adapter which might delegate serialization to another adapter.\n+ */\n+public abstract class SerializationDelegatingTypeAdapter<T> extends TypeAdapter<T> {\n+  /**\n+   * Returns the adapter used for serialization, might be {@code this} or another adapter.\n+   * That other adapter might itself also be a {@code SerializationDelegatingTypeAdapter}.\n+   */\n+  public abstract TypeAdapter<T> getSerializationDelegate();\n+}\ndiff --git a/gson/src/main/java/com/google/gson/internal/bind/TreeTypeAdapter.java b/gson/src/main/java/com/google/gson/internal/bind/TreeTypeAdapter.java\nindex b7e924959f..560234c07c 100644\n--- a/gson/src/main/java/com/google/gson/internal/bind/TreeTypeAdapter.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/TreeTypeAdapter.java\n@@ -38,7 +38,7 @@\n  * tree adapter may be serialization-only or deserialization-only, this class\n  * has a facility to lookup a delegate type adapter on demand.\n  */\n-public final class TreeTypeAdapter<T> extends TypeAdapter<T> {\n+public final class TreeTypeAdapter<T> extends SerializationDelegatingTypeAdapter<T> {\n   private final JsonSerializer<T> serializer;\n   private final JsonDeserializer<T> deserializer;\n   final Gson gson;\n@@ -97,6 +97,15 @@ private TypeAdapter<T> delegate() {\n         : (delegate = gson.getDelegateAdapter(skipPast, typeToken));\n   }\n \n+  /**\n+   * Returns the type adapter which is used for serialization. Returns {@code this}\n+   * if this {@code TreeTypeAdapter} has a {@link #serializer}; otherwise returns\n+   * the delegate.\n+   */\n+  @Override public TypeAdapter<T> getSerializationDelegate() {\n+    return serializer != null ? this : delegate();\n+  }\n+\n   /**\n    * Returns a new factory that will match each type against {@code exactType}.\n    */\n@@ -169,5 +178,5 @@ private final class GsonContextImpl implements JsonSerializationContext, JsonDes\n     @Override public <R> R deserialize(JsonElement json, Type typeOfT) throws JsonParseException {\n       return (R) gson.fromJson(json, typeOfT);\n     }\n-  };\n+  }\n }\ndiff --git a/gson/src/main/java/com/google/gson/internal/bind/TypeAdapterRuntimeTypeWrapper.java b/gson/src/main/java/com/google/gson/internal/bind/TypeAdapterRuntimeTypeWrapper.java\nindex 6a6909191d..75a991ead7 100644\n--- a/gson/src/main/java/com/google/gson/internal/bind/TypeAdapterRuntimeTypeWrapper.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/TypeAdapterRuntimeTypeWrapper.java\n@@ -53,10 +53,12 @@ public void write(JsonWriter out, T value) throws IOException {\n     if (runtimeType != type) {\r\n       @SuppressWarnings(\"unchecked\")\r\n       TypeAdapter<T> runtimeTypeAdapter = (TypeAdapter<T>) context.getAdapter(TypeToken.get(runtimeType));\r\n+      // For backward compatibility only check ReflectiveTypeAdapterFactory.Adapter here but not any other\r\n+      // wrapping adapters, see https://github.com/google/gson/pull/1787#issuecomment-1222175189\r\n       if (!(runtimeTypeAdapter instanceof ReflectiveTypeAdapterFactory.Adapter)) {\r\n         // The user registered a type adapter for the runtime type, so we will use that\r\n         chosen = runtimeTypeAdapter;\r\n-      } else if (!(delegate instanceof ReflectiveTypeAdapterFactory.Adapter)) {\r\n+      } else if (!isReflective(delegate)) {\r\n         // The user registered a type adapter for Base class, so we prefer it over the\r\n         // reflective type adapter for the runtime type\r\n         chosen = delegate;\r\n@@ -68,12 +70,30 @@ public void write(JsonWriter out, T value) throws IOException {\n     chosen.write(out, value);\r\n   }\r\n \r\n+  /**\r\n+   * Returns whether the type adapter uses reflection.\r\n+   *\r\n+   * @param typeAdapter the type adapter to check.\r\n+   */\r\n+  private static boolean isReflective(TypeAdapter<?> typeAdapter) {\r\n+    // Run this in loop in case multiple delegating adapters are nested\r\n+    while (typeAdapter instanceof SerializationDelegatingTypeAdapter) {\r\n+      TypeAdapter<?> delegate = ((SerializationDelegatingTypeAdapter<?>) typeAdapter).getSerializationDelegate();\r\n+      // Break if adapter does not delegate serialization\r\n+      if (delegate == typeAdapter) {\r\n+        break;\r\n+      }\r\n+      typeAdapter = delegate;\r\n+    }\r\n+\r\n+    return typeAdapter instanceof ReflectiveTypeAdapterFactory.Adapter;\r\n+  }\r\n+\r\n   /**\r\n    * Finds a compatible runtime type if it is more specific\r\n    */\r\n-  private Type getRuntimeTypeIfMoreSpecific(Type type, Object value) {\r\n-    if (value != null\r\n-        && (type == Object.class || type instanceof TypeVariable<?> || type instanceof Class<?>)) {\r\n+  private static Type getRuntimeTypeIfMoreSpecific(Type type, Object value) {\r\n+    if (value != null && (type instanceof Class<?> || type instanceof TypeVariable<?>)) {\r\n       type = value.getClass();\r\n     }\r\n     return type;\r\n", "test_patch": "diff --git a/gson/src/test/java/com/google/gson/functional/TypeAdapterRuntimeTypeWrapperTest.java b/gson/src/test/java/com/google/gson/functional/TypeAdapterRuntimeTypeWrapperTest.java\nnew file mode 100644\nindex 0000000000..73a0101243\n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/functional/TypeAdapterRuntimeTypeWrapperTest.java\n@@ -0,0 +1,193 @@\n+package com.google.gson.functional;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonDeserializationContext;\n+import com.google.gson.JsonDeserializer;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.JsonSerializationContext;\n+import com.google.gson.JsonSerializer;\n+import com.google.gson.TypeAdapter;\n+import com.google.gson.stream.JsonReader;\n+import com.google.gson.stream.JsonWriter;\n+import java.io.IOException;\n+import java.lang.reflect.Type;\n+import org.junit.Test;\n+\n+public class TypeAdapterRuntimeTypeWrapperTest {\n+  private static class Base {\n+  }\n+  private static class Subclass extends Base {\n+    @SuppressWarnings(\"unused\")\n+    String f = \"test\";\n+  }\n+  private static class Container {\n+    @SuppressWarnings(\"unused\")\n+    Base b = new Subclass();\n+  }\n+  private static class Deserializer implements JsonDeserializer<Base> {\n+    @Override\n+    public Base deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) {\n+      throw new AssertionError(\"not needed for this test\");\n+    }\n+  }\n+\n+  /**\n+   * When custom {@link JsonSerializer} is registered for Base should\n+   * prefer that over reflective adapter for Subclass for serialization.\n+   */\n+  @Test\n+  public void testJsonSerializer() {\n+    Gson gson = new GsonBuilder()\n+      .registerTypeAdapter(Base.class, new JsonSerializer<Base>() {\n+        @Override\n+        public JsonElement serialize(Base src, Type typeOfSrc, JsonSerializationContext context) {\n+          return new JsonPrimitive(\"serializer\");\n+        }\n+      })\n+      .create();\n+\n+    String json = gson.toJson(new Container());\n+    assertEquals(\"{\\\"b\\\":\\\"serializer\\\"}\", json);\n+  }\n+\n+  /**\n+   * When only {@link JsonDeserializer} is registered for Base, then on\n+   * serialization should prefer reflective adapter for Subclass since\n+   * Base would use reflective adapter as delegate.\n+   */\n+  @Test\n+  public void testJsonDeserializer_ReflectiveSerializerDelegate() {\n+    Gson gson = new GsonBuilder()\n+      .registerTypeAdapter(Base.class, new Deserializer())\n+      .create();\n+\n+    String json = gson.toJson(new Container());\n+    assertEquals(\"{\\\"b\\\":{\\\"f\\\":\\\"test\\\"}}\", json);\n+  }\n+\n+  /**\n+   * When {@link JsonDeserializer} with custom adapter as delegate is\n+   * registered for Base, then on serialization should prefer custom adapter\n+   * delegate for Base over reflective adapter for Subclass.\n+   */\n+  @Test\n+  public void testJsonDeserializer_CustomSerializerDelegate() {\n+    Gson gson = new GsonBuilder()\n+      // Register custom delegate\n+      .registerTypeAdapter(Base.class, new TypeAdapter<Base>() {\n+        @Override\n+        public Base read(JsonReader in) throws IOException {\n+          throw new UnsupportedOperationException();\n+        }\n+        @Override\n+        public void write(JsonWriter out, Base value) throws IOException {\n+          out.value(\"custom delegate\");\n+        }\n+      })\n+      .registerTypeAdapter(Base.class, new Deserializer())\n+      .create();\n+\n+    String json = gson.toJson(new Container());\n+    assertEquals(\"{\\\"b\\\":\\\"custom delegate\\\"}\", json);\n+  }\n+\n+  /**\n+   * When two (or more) {@link JsonDeserializer}s are registered for Base\n+   * which eventually fall back to reflective adapter as delegate, then on\n+   * serialization should prefer reflective adapter for Subclass.\n+   */\n+  @Test\n+  public void testJsonDeserializer_ReflectiveTreeSerializerDelegate() {\n+    Gson gson = new GsonBuilder()\n+      // Register delegate which itself falls back to reflective serialization\n+      .registerTypeAdapter(Base.class, new Deserializer())\n+      .registerTypeAdapter(Base.class, new Deserializer())\n+      .create();\n+\n+    String json = gson.toJson(new Container());\n+    assertEquals(\"{\\\"b\\\":{\\\"f\\\":\\\"test\\\"}}\", json);\n+  }\n+\n+  /**\n+   * When {@link JsonDeserializer} with {@link JsonSerializer} as delegate\n+   * is registered for Base, then on serialization should prefer\n+   * {@code JsonSerializer} over reflective adapter for Subclass.\n+   */\n+  @Test\n+  public void testJsonDeserializer_JsonSerializerDelegate() {\n+    Gson gson = new GsonBuilder()\n+      // Register JsonSerializer as delegate\n+      .registerTypeAdapter(Base.class, new JsonSerializer<Base>() {\n+        @Override\n+        public JsonElement serialize(Base src, Type typeOfSrc, JsonSerializationContext context) {\n+          return new JsonPrimitive(\"custom delegate\");\n+        }\n+      })\n+      .registerTypeAdapter(Base.class, new Deserializer())\n+      .create();\n+\n+    String json = gson.toJson(new Container());\n+    assertEquals(\"{\\\"b\\\":\\\"custom delegate\\\"}\", json);\n+  }\n+\n+  /**\n+   * When a {@link JsonDeserializer} is registered for Subclass, and a custom\n+   * {@link JsonSerializer} is registered for Base, then Gson should prefer\n+   * the reflective adapter for Subclass for backward compatibility (see\n+   * https://github.com/google/gson/pull/1787#issuecomment-1222175189) even\n+   * though normally TypeAdapterRuntimeTypeWrapper should prefer the custom\n+   * serializer for Base.\n+   */\n+  @Test\n+  public void testJsonDeserializer_SubclassBackwardCompatibility() {\n+    Gson gson = new GsonBuilder()\n+      .registerTypeAdapter(Subclass.class, new JsonDeserializer<Subclass>() {\n+        @Override\n+        public Subclass deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) {\n+          throw new AssertionError(\"not needed for this test\");\n+        }\n+      })\n+      .registerTypeAdapter(Base.class, new JsonSerializer<Base>() {\n+        @Override\n+        public JsonElement serialize(Base src, Type typeOfSrc, JsonSerializationContext context) {\n+          return new JsonPrimitive(\"base\");\n+        }\n+      })\n+      .create();\n+\n+    String json = gson.toJson(new Container());\n+    assertEquals(\"{\\\"b\\\":{\\\"f\\\":\\\"test\\\"}}\", json);\n+  }\n+\n+  private static class CyclicBase {\n+    @SuppressWarnings(\"unused\")\n+    CyclicBase f;\n+  }\n+\n+  private static class CyclicSub extends CyclicBase {\n+    @SuppressWarnings(\"unused\")\n+    int i;\n+\n+    public CyclicSub(int i) {\n+      this.i = i;\n+    }\n+  }\n+\n+  /**\n+   * Tests behavior when the type of a field refers to a type whose adapter is\n+   * currently in the process of being created. For these cases {@link Gson}\n+   * uses a future adapter for the type. That adapter later uses the actual\n+   * adapter as delegate.\n+   */\n+  @Test\n+  public void testGsonFutureAdapter() {\n+    CyclicBase b = new CyclicBase();\n+    b.f = new CyclicSub(2);\n+    String json = new Gson().toJson(b);\n+    assertEquals(\"{\\\"f\\\":{\\\"i\\\":2}}\", json);\n+  }\n+}\n", "fixed_tests": {"com.google.gson.protobuf.functional.ProtosWithPrimitiveTypesTest": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "com.google.gson.typeadapters.PostConstructAdapterFactoryTest": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "com.google.gson.interceptors.InterceptorTest": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "com.google.gson.typeadapters.RuntimeTypeAdapterFactoryTest": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "com.google.gson.graph.GraphAdapterBuilderTest": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "com.google.gson.typeadapters.UtcDateTypeAdapterTest": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "com.google.gson.protobuf.functional.ProtosWithComplexAndRepeatedFieldsTest": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "com.google.gson.protobuf.functional.ProtosWithAnnotationsTest": {"run": "PASS", "test": "NONE", "fix": "PASS"}}, "p2p_tests": {}, "f2p_tests": {}, "s2p_tests": {}, "n2p_tests": {"com.google.gson.protobuf.functional.ProtosWithPrimitiveTypesTest": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "com.google.gson.typeadapters.PostConstructAdapterFactoryTest": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "com.google.gson.interceptors.InterceptorTest": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "com.google.gson.typeadapters.RuntimeTypeAdapterFactoryTest": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "com.google.gson.graph.GraphAdapterBuilderTest": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "com.google.gson.typeadapters.UtcDateTypeAdapterTest": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "com.google.gson.protobuf.functional.ProtosWithComplexAndRepeatedFieldsTest": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "com.google.gson.protobuf.functional.ProtosWithAnnotationsTest": {"run": "PASS", "test": "NONE", "fix": "PASS"}}, "run_result": {"passed_count": 8, "failed_count": 0, "skipped_count": 0, "passed_tests": ["com.google.gson.protobuf.functional.ProtosWithPrimitiveTypesTest", "com.google.gson.typeadapters.PostConstructAdapterFactoryTest", "com.google.gson.interceptors.InterceptorTest", "com.google.gson.typeadapters.RuntimeTypeAdapterFactoryTest", "com.google.gson.graph.GraphAdapterBuilderTest", "com.google.gson.typeadapters.UtcDateTypeAdapterTest", "com.google.gson.protobuf.functional.ProtosWithComplexAndRepeatedFieldsTest", "com.google.gson.protobuf.functional.ProtosWithAnnotationsTest"], "failed_tests": [], "skipped_tests": []}, "test_patch_result": {"passed_count": 0, "failed_count": 0, "skipped_count": 0, "passed_tests": [], "failed_tests": [], "skipped_tests": []}, "fix_patch_result": {"passed_count": 8, "failed_count": 0, "skipped_count": 0, "passed_tests": ["com.google.gson.protobuf.functional.ProtosWithPrimitiveTypesTest", "com.google.gson.typeadapters.PostConstructAdapterFactoryTest", "com.google.gson.interceptors.InterceptorTest", "com.google.gson.typeadapters.RuntimeTypeAdapterFactoryTest", "com.google.gson.graph.GraphAdapterBuilderTest", "com.google.gson.typeadapters.UtcDateTypeAdapterTest", "com.google.gson.protobuf.functional.ProtosWithComplexAndRepeatedFieldsTest", "com.google.gson.protobuf.functional.ProtosWithAnnotationsTest"], "failed_tests": [], "skipped_tests": []}, "instance_id": "google__gson-1787"}
{"org": "google", "repo": "gson", "number": 1703, "state": "closed", "title": "Fix #1702: Gson.toJson creates CharSequence which does not implement toString", "body": "Fix #1702", "base": {"label": "google:master", "ref": "master", "sha": "6d2557d5d1a8ac498f2bcee20e5053c93b33ecce"}, "resolved_issues": [{"number": 1702, "title": "Gson.toJson: CharSequence passed to Appendable does not implement toString()", "body": "When calling `Gson.toJson(..., Appendable)` and `Appendable` is not an instance of `Writer`, then `Gson` creates a `CharSequence` which does not fulfill the `toString()` requirements:\r\n> Returns a string containing the characters in this sequence in the same order as this sequence.  The length of the string will be the length of this sequence.\r\n\r\nContrived example:\r\n```\r\nstatic class MyAppendable implements Appendable {\r\n    private final StringBuilder stringBuilder = new StringBuilder();\r\n    \r\n    @Override\r\n    public Appendable append(char c) throws IOException {\r\n        stringBuilder.append(c);\r\n        return this;\r\n    }\r\n    \r\n    @Override\r\n    public Appendable append(CharSequence csq) throws IOException {\r\n        if (csq == null) {\r\n            append(\"null\");\r\n        } else {\r\n            append(csq, 0, csq.length());\r\n        }\r\n        return this;\r\n    }\r\n    \r\n    public Appendable append(CharSequence csq, int start, int end) throws IOException {\r\n        if (csq == null) {\r\n            csq == \"null\";\r\n        }\r\n        \r\n        // According to doc, toString() must return string representation\r\n        String s = csq.toString();\r\n        stringBuilder.append(s, start, end);\r\n        return this;\r\n    }\r\n}\r\n\r\npublic static void main(String[] args) {\r\n    MyAppendable myAppendable = new MyAppendable();\r\n    new Gson().toJson(\"test\", myAppendable);\r\n    // Prints `com.` (first 4 chars of `com.google.gson.internal.Streams.AppendableWriter.CurrentWrite`)\r\n    System.out.println(myAppendable.stringBuilder);\r\n}\r\n```"}], "fix_patch": "diff --git a/gson/src/main/java/com/google/gson/internal/Streams.java b/gson/src/main/java/com/google/gson/internal/Streams.java\nindex 0bb73aa18e..c1ce2a452a 100644\n--- a/gson/src/main/java/com/google/gson/internal/Streams.java\n+++ b/gson/src/main/java/com/google/gson/internal/Streams.java\n@@ -89,7 +89,7 @@ private static final class AppendableWriter extends Writer {\n     }\n \n     @Override public void write(char[] chars, int offset, int length) throws IOException {\n-      currentWrite.chars = chars;\n+      currentWrite.setChars(chars);\n       appendable.append(currentWrite, offset, offset + length);\n     }\n \n@@ -103,8 +103,15 @@ private static final class AppendableWriter extends Writer {\n     /**\n      * A mutable char sequence pointing at a single char[].\n      */\n-    static class CurrentWrite implements CharSequence {\n-      char[] chars;\n+    private static class CurrentWrite implements CharSequence {\n+      private char[] chars;\n+      private String cachedString;\n+\n+      void setChars(char[] chars) {\n+        this.chars = chars;\n+        this.cachedString = null;\n+      }\n+\n       @Override public int length() {\n         return chars.length;\n       }\n@@ -114,7 +121,14 @@ static class CurrentWrite implements CharSequence {\n       @Override public CharSequence subSequence(int start, int end) {\n         return new String(chars, start, end - start);\n       }\n+\n+      // Must return string representation to satisfy toString() contract\n+      @Override public String toString() {\n+        if (cachedString == null) {\n+          cachedString = new String(chars);\n+        }\n+        return cachedString;\n+      }\n     }\n   }\n-\n }\n", "test_patch": "diff --git a/gson/src/test/java/com/google/gson/functional/ReadersWritersTest.java b/gson/src/test/java/com/google/gson/functional/ReadersWritersTest.java\nindex e21fb903e4..a04723b576 100644\n--- a/gson/src/test/java/com/google/gson/functional/ReadersWritersTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/ReadersWritersTest.java\n@@ -20,11 +20,7 @@\n import com.google.gson.JsonStreamParser;\n import com.google.gson.JsonSyntaxException;\n import com.google.gson.common.TestTypes.BagOfPrimitives;\n-\n import com.google.gson.reflect.TypeToken;\n-import java.util.Map;\n-import junit.framework.TestCase;\n-\n import java.io.CharArrayReader;\n import java.io.CharArrayWriter;\n import java.io.IOException;\n@@ -32,6 +28,9 @@\n import java.io.StringReader;\n import java.io.StringWriter;\n import java.io.Writer;\n+import java.util.Arrays;\n+import java.util.Map;\n+import junit.framework.TestCase;\n \n /**\n  * Functional tests for the support of {@link Reader}s and {@link Writer}s.\n@@ -89,8 +88,8 @@ public void testTopLevelNullObjectDeserializationWithReaderAndSerializeNulls() {\n   }\n \n   public void testReadWriteTwoStrings() throws IOException {\n-    Gson gson= new Gson();\n-    CharArrayWriter writer= new CharArrayWriter();\n+    Gson gson = new Gson();\n+    CharArrayWriter writer = new CharArrayWriter();\n     writer.write(gson.toJson(\"one\").toCharArray());\n     writer.write(gson.toJson(\"two\").toCharArray());\n     CharArrayReader reader = new CharArrayReader(writer.toCharArray());\n@@ -102,8 +101,8 @@ public void testReadWriteTwoStrings() throws IOException {\n   }\n \n   public void testReadWriteTwoObjects() throws IOException {\n-    Gson gson= new Gson();\n-    CharArrayWriter writer= new CharArrayWriter();\n+    Gson gson = new Gson();\n+    CharArrayWriter writer = new CharArrayWriter();\n     BagOfPrimitives expectedOne = new BagOfPrimitives(1, 1, true, \"one\");\n     writer.write(gson.toJson(expectedOne).toCharArray());\n     BagOfPrimitives expectedTwo = new BagOfPrimitives(2, 2, false, \"two\");\n@@ -132,4 +131,50 @@ public void testTypeMismatchThrowsJsonSyntaxExceptionForReaders() {\n     } catch (JsonSyntaxException expected) {\n     }\n   }\n+\n+  /**\n+   * Verifies that passing an {@link Appendable} which is not an instance of {@link Writer}\n+   * to {@code Gson.toJson} works correctly.\n+   */\n+  public void testToJsonAppendable() {\n+    class CustomAppendable implements Appendable {\n+      final StringBuilder stringBuilder = new StringBuilder();\n+      int toStringCallCount = 0;\n+\n+      @Override\n+      public Appendable append(char c) throws IOException {\n+        stringBuilder.append(c);\n+        return this;\n+      }\n+\n+      @Override\n+      public Appendable append(CharSequence csq) throws IOException {\n+        if (csq == null) {\n+          csq = \"null\"; // Requirement by Writer.append\n+        }\n+        append(csq, 0, csq.length());\n+        return this;\n+      }\n+\n+      @Override\n+      public Appendable append(CharSequence csq, int start, int end) throws IOException {\n+        if (csq == null) {\n+          csq = \"null\"; // Requirement by Writer.append\n+        }\n+\n+        // According to doc, toString() must return string representation\n+        String s = csq.toString();\n+        toStringCallCount++;\n+        stringBuilder.append(s, start, end);\n+        return this;\n+      }\n+    }\n+\n+    CustomAppendable appendable = new CustomAppendable();\n+    gson.toJson(Arrays.asList(\"test\", 123, true), appendable);\n+    // Make sure CharSequence.toString() was called at least two times to verify that\n+    // CurrentWrite.cachedString is properly overwritten when char array changes\n+    assertTrue(appendable.toStringCallCount >= 2);\n+    assertEquals(\"[\\\"test\\\",123,true]\", appendable.stringBuilder.toString());\n+  }\n }\n", "fixed_tests": {"com.google.gson.protobuf.functional.ProtosWithPrimitiveTypesTest": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "com.google.gson.typeadapters.PostConstructAdapterFactoryTest": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "com.google.gson.interceptors.InterceptorTest": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "com.google.gson.typeadapters.RuntimeTypeAdapterFactoryTest": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "com.google.gson.graph.GraphAdapterBuilderTest": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "com.google.gson.typeadapters.UtcDateTypeAdapterTest": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "com.google.gson.protobuf.functional.ProtosWithComplexAndRepeatedFieldsTest": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "com.google.gson.protobuf.functional.ProtosWithAnnotationsTest": {"run": "PASS", "test": "NONE", "fix": "PASS"}}, "p2p_tests": {}, "f2p_tests": {}, "s2p_tests": {}, "n2p_tests": {"com.google.gson.protobuf.functional.ProtosWithPrimitiveTypesTest": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "com.google.gson.typeadapters.PostConstructAdapterFactoryTest": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "com.google.gson.interceptors.InterceptorTest": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "com.google.gson.typeadapters.RuntimeTypeAdapterFactoryTest": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "com.google.gson.graph.GraphAdapterBuilderTest": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "com.google.gson.typeadapters.UtcDateTypeAdapterTest": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "com.google.gson.protobuf.functional.ProtosWithComplexAndRepeatedFieldsTest": {"run": "PASS", "test": "NONE", "fix": "PASS"}, "com.google.gson.protobuf.functional.ProtosWithAnnotationsTest": {"run": "PASS", "test": "NONE", "fix": "PASS"}}, "run_result": {"passed_count": 8, "failed_count": 0, "skipped_count": 0, "passed_tests": ["com.google.gson.protobuf.functional.ProtosWithPrimitiveTypesTest", "com.google.gson.typeadapters.PostConstructAdapterFactoryTest", "com.google.gson.interceptors.InterceptorTest", "com.google.gson.typeadapters.RuntimeTypeAdapterFactoryTest", "com.google.gson.graph.GraphAdapterBuilderTest", "com.google.gson.typeadapters.UtcDateTypeAdapterTest", "com.google.gson.protobuf.functional.ProtosWithComplexAndRepeatedFieldsTest", "com.google.gson.protobuf.functional.ProtosWithAnnotationsTest"], "failed_tests": [], "skipped_tests": []}, "test_patch_result": {"passed_count": 0, "failed_count": 0, "skipped_count": 0, "passed_tests": [], "failed_tests": [], "skipped_tests": []}, "fix_patch_result": {"passed_count": 8, "failed_count": 0, "skipped_count": 0, "passed_tests": ["com.google.gson.protobuf.functional.ProtosWithPrimitiveTypesTest", "com.google.gson.typeadapters.PostConstructAdapterFactoryTest", "com.google.gson.interceptors.InterceptorTest", "com.google.gson.typeadapters.RuntimeTypeAdapterFactoryTest", "com.google.gson.graph.GraphAdapterBuilderTest", "com.google.gson.typeadapters.UtcDateTypeAdapterTest", "com.google.gson.protobuf.functional.ProtosWithComplexAndRepeatedFieldsTest", "com.google.gson.protobuf.functional.ProtosWithAnnotationsTest"], "failed_tests": [], "skipped_tests": []}, "instance_id": "google__gson-1703"}
{"org": "google", "repo": "gson", "number": 1555, "state": "closed", "title": "Fixed nullSafe usage.", "body": "It is impossible to create a JsonDeserializer that transforms JSON null values. This PR makes it so that a serializer/deserializer for annotated field does get called on nulls when `nullSafe` property of JsonAdapter annotation is false.\r\n\r\nnullSafe is still ignored if adapter is registered via GsonBuilder.\r\n\r\nFixes #1553\r\n\r\nSigned-off-by: Dmitry Bufistov <dmitry@midokura.com>", "base": {"label": "google:master", "ref": "master", "sha": "aa236ec38d39f434c1641aeaef9241aec18affde"}, "resolved_issues": [{"number": 1553, "title": "JsonAdapter nullSafe parameter is ignored by JsonSerializer/JsonDeserializer type adapters", "body": "Hi there,\r\n\r\nIt looks like gson uses TreeTypeAdapter for JsonSerializer/JsonDeserializer type adapters.\r\nTreeTypeAdapter is always nullSafe, so nullSafe value of JsonAdapter annotation is ignored in this case which is at least confusing.\r\n\r\nI fixed this locally by adding nullSafe parameter to the TreeTypeAdapter and would love to submit a PR if it need be. Shall I go ahead?\r\n\r\nThanks!"}], "fix_patch": "diff --git a/gson/src/main/java/com/google/gson/internal/bind/JsonAdapterAnnotationTypeAdapterFactory.java b/gson/src/main/java/com/google/gson/internal/bind/JsonAdapterAnnotationTypeAdapterFactory.java\nindex 13a7bb7ebe..d75e4ee04a 100644\n--- a/gson/src/main/java/com/google/gson/internal/bind/JsonAdapterAnnotationTypeAdapterFactory.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/JsonAdapterAnnotationTypeAdapterFactory.java\n@@ -55,6 +55,7 @@ TypeAdapter<?> getTypeAdapter(ConstructorConstructor constructorConstructor, Gso\n     Object instance = constructorConstructor.get(TypeToken.get(annotation.value())).construct();\n \n     TypeAdapter<?> typeAdapter;\n+    boolean nullSafe = annotation.nullSafe();\n     if (instance instanceof TypeAdapter) {\n       typeAdapter = (TypeAdapter<?>) instance;\n     } else if (instance instanceof TypeAdapterFactory) {\n@@ -66,7 +67,8 @@ TypeAdapter<?> getTypeAdapter(ConstructorConstructor constructorConstructor, Gso\n       JsonDeserializer<?> deserializer = instance instanceof JsonDeserializer\n           ? (JsonDeserializer) instance\n           : null;\n-      typeAdapter = new TreeTypeAdapter(serializer, deserializer, gson, type, null);\n+      typeAdapter = new TreeTypeAdapter(serializer, deserializer, gson, type, null, nullSafe);\n+      nullSafe = false;\n     } else {\n       throw new IllegalArgumentException(\"Invalid attempt to bind an instance of \"\n           + instance.getClass().getName() + \" as a @JsonAdapter for \" + type.toString()\n@@ -74,7 +76,7 @@ TypeAdapter<?> getTypeAdapter(ConstructorConstructor constructorConstructor, Gso\n           + \" JsonSerializer or JsonDeserializer.\");\n     }\n \n-    if (typeAdapter != null && annotation.nullSafe()) {\n+    if (typeAdapter != null && nullSafe) {\n       typeAdapter = typeAdapter.nullSafe();\n     }\n \ndiff --git a/gson/src/main/java/com/google/gson/internal/bind/TreeTypeAdapter.java b/gson/src/main/java/com/google/gson/internal/bind/TreeTypeAdapter.java\nindex a5c6c5dcda..a216c06aca 100644\n--- a/gson/src/main/java/com/google/gson/internal/bind/TreeTypeAdapter.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/TreeTypeAdapter.java\n@@ -45,17 +45,24 @@ public final class TreeTypeAdapter<T> extends TypeAdapter<T> {\n   private final TypeToken<T> typeToken;\n   private final TypeAdapterFactory skipPast;\n   private final GsonContextImpl context = new GsonContextImpl();\n+  private final boolean nullSafe;\n \n   /** The delegate is lazily created because it may not be needed, and creating it may fail. */\n   private TypeAdapter<T> delegate;\n \n   public TreeTypeAdapter(JsonSerializer<T> serializer, JsonDeserializer<T> deserializer,\n-      Gson gson, TypeToken<T> typeToken, TypeAdapterFactory skipPast) {\n+      Gson gson, TypeToken<T> typeToken, TypeAdapterFactory skipPast, boolean nullSafe) {\n     this.serializer = serializer;\n     this.deserializer = deserializer;\n     this.gson = gson;\n     this.typeToken = typeToken;\n     this.skipPast = skipPast;\n+    this.nullSafe = nullSafe;\n+  }\n+\n+  public TreeTypeAdapter(JsonSerializer<T> serializer, JsonDeserializer<T> deserializer,\n+                         Gson gson, TypeToken<T> typeToken, TypeAdapterFactory skipPast) {\n+    this(serializer, deserializer, gson, typeToken, skipPast, true);\n   }\n \n   @Override public T read(JsonReader in) throws IOException {\n@@ -63,7 +70,7 @@ public TreeTypeAdapter(JsonSerializer<T> serializer, JsonDeserializer<T> deseria\n       return delegate().read(in);\n     }\n     JsonElement value = Streams.parse(in);\n-    if (value.isJsonNull()) {\n+    if (nullSafe && value.isJsonNull()) {\n       return null;\n     }\n     return deserializer.deserialize(value, typeToken.getType(), context);\n@@ -74,7 +81,7 @@ public TreeTypeAdapter(JsonSerializer<T> serializer, JsonDeserializer<T> deseria\n       delegate().write(out, value);\n       return;\n     }\n-    if (value == null) {\n+    if (nullSafe && value == null) {\n       out.nullValue();\n       return;\n     }\n", "test_patch": "diff --git a/gson/src/test/java/com/google/gson/functional/JsonAdapterSerializerDeserializerTest.java b/gson/src/test/java/com/google/gson/functional/JsonAdapterSerializerDeserializerTest.java\nindex 8ab4e128a6..b4dfc3593c 100644\n--- a/gson/src/test/java/com/google/gson/functional/JsonAdapterSerializerDeserializerTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/JsonAdapterSerializerDeserializerTest.java\n@@ -161,4 +161,22 @@ private static final class BaseIntegerAdapter implements JsonSerializer<Base<Int\n       return new JsonPrimitive(\"BaseIntegerAdapter\");\n     }\n   }\n+\n+  public void testJsonAdapterNullSafe() {\n+    Gson gson = new Gson();\n+    String json = gson.toJson(new Computer3(null, null));\n+    assertEquals(\"{\\\"user1\\\":\\\"UserSerializerDeserializer\\\"}\", json);\n+    Computer3 computer3 = gson.fromJson(\"{\\\"user1\\\":null, \\\"user2\\\":null}\", Computer3.class);\n+    assertEquals(\"UserSerializerDeserializer\", computer3.user1.name);\n+    assertNull(computer3.user2);\n+  }\n+\n+  private static final class Computer3 {\n+    @JsonAdapter(value = UserSerializerDeserializer.class, nullSafe = false) final User user1;\n+    @JsonAdapter(value = UserSerializerDeserializer.class) final User user2;\n+    Computer3(User user1, User user2) {\n+      this.user1 = user1;\n+      this.user2 = user2;\n+    }\n+  }\n }\n", "fixed_tests": {"com.google.gson.functional.JsonAdapterSerializerDeserializerTest": {"run": "PASS", "test": "FAIL", "fix": "PASS"}}, "p2p_tests": {"com.google.gson.stream.JsonReaderTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.FieldNamingTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.GsonVersionDiagnosticsTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.InstanceCreatorTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.JsonAdapterAnnotationOnFieldsTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.CustomTypeAdaptersTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.JsonStreamParserTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.internal.reflect.UnsafeReflectionAccessorTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.PrimitiveCharacterTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.ArrayTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.internal.bind.JsonTreeReaderTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.DefaultInetAddressTypeAdapterTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.internal.GsonTypesTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.DelegateTypeAdapterTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.internal.bind.JsonElementReaderTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.MoreSpecificTypeSerializationTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.stream.JsonWriterTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.StringTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.metrics.PerformanceTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.stream.JsonReaderPathTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.PrettyPrintingTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.ExclusionStrategyFunctionalTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.JsonAdapterAnnotationOnClassesTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.TypeHierarchyAdapterTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.ObjectTypeAdapterTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.PrimitiveTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.GenericArrayTypeTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.JsonArrayTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.JavaUtilTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.JavaUtilConcurrentAtomicTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.NullObjectAndFieldTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.JsonNullTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.internal.UnsafeAllocatorInstantiationTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.SecurityTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.MapTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.EnumTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.GsonBuilderTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.ConcurrencyTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.internal.bind.JsonTreeWriterTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.ParameterizedTypeTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.RuntimeTypeAdapterFactoryFunctionalTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.EscapingTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.CustomDeserializerTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.TypeAdapterPrecedenceTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.internal.GsonBuildConfigTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.reflect.TypeTokenTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.internal.LinkedHashTreeMapTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.InheritanceTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.UncategorizedTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.ParameterizedTypesTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.InnerClassExclusionStrategyTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.JsonTreeTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.VersioningTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.OverrideCoreTypeAdaptersTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.internal.LinkedTreeMapTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.CollectionTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.LeniencyTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.CustomSerializerTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.TypeVariableTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.MapAsArrayTypeAdapterTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.RawSerializationTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.GsonTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.ReadersWritersTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.ExposeAnnotationExclusionStrategyTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.InternationalizationTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.MixedStreamTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.internal.bind.RecursiveTypesResolveTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.FieldExclusionTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.PrintFormattingTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.internal.LazilyParsedNumberTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.JsonObjectTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.StreamingTypeAdaptersTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.JavaSerializationTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.ThrowableFunctionalTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.JsonArrayTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.DefaultTypeAdaptersTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.ObjectTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.FieldAttributesTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.CircularReferenceTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.NamingPolicyTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.ExposeFieldsTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.LongSerializationPolicyTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.DefaultMapJsonSerializerTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.CommentsTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.internal.JavaVersionTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.TreeTypeAdaptersTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.VersionExclusionStrategyTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.JsonParserTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.JsonPrimitiveTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.InterfaceTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.JsonParserTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.GsonTypeAdapterTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.regression.JsonAdapterNullSafeTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.SerializedNameTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}}, "f2p_tests": {"com.google.gson.functional.JsonAdapterSerializerDeserializerTest": {"run": "PASS", "test": "FAIL", "fix": "PASS"}}, "s2p_tests": {}, "n2p_tests": {}, "run_result": {"passed_count": 95, "failed_count": 1, "skipped_count": 0, "passed_tests": ["com.google.gson.functional.FieldNamingTest", "com.google.gson.functional.InstanceCreatorTest", "com.google.gson.functional.CustomTypeAdaptersTest", "com.google.gson.JsonStreamParserTest", "com.google.gson.functional.PrimitiveCharacterTest", "com.google.gson.functional.DelegateTypeAdapterTest", "com.google.gson.stream.JsonWriterTest", "com.google.gson.metrics.PerformanceTest", "com.google.gson.stream.JsonReaderPathTest", "com.google.gson.functional.PrettyPrintingTest", "com.google.gson.functional.JsonAdapterAnnotationOnClassesTest", "com.google.gson.functional.TypeHierarchyAdapterTest", "com.google.gson.ObjectTypeAdapterTest", "com.google.gson.GenericArrayTypeTest", "com.google.gson.JsonArrayTest", "com.google.gson.functional.JavaUtilConcurrentAtomicTest", "com.google.gson.JsonNullTest", "com.google.gson.functional.SecurityTest", "com.google.gson.functional.MapTest", "com.google.gson.functional.EnumTest", "com.google.gson.functional.ConcurrencyTest", "com.google.gson.functional.CustomDeserializerTest", "com.google.gson.functional.TypeAdapterPrecedenceTest", "com.google.gson.internal.GsonBuildConfigTest", "com.google.gson.reflect.TypeTokenTest", "com.google.gson.internal.LinkedHashTreeMapTest", "com.google.gson.functional.InheritanceTest", "com.google.gson.InnerClassExclusionStrategyTest", "com.google.gson.OverrideCoreTypeAdaptersTest", "com.google.gson.functional.CollectionTest", "com.google.gson.functional.LeniencyTest", "com.google.gson.functional.TypeVariableTest", "com.google.gson.GsonTest", "com.google.gson.functional.InternationalizationTest", "com.google.gson.functional.FieldExclusionTest", "com.google.gson.functional.DefaultTypeAdaptersTest", "com.google.gson.FieldAttributesTest", "com.google.gson.functional.CircularReferenceTest", "com.google.gson.functional.NamingPolicyTest", "com.google.gson.functional.ExposeFieldsTest", "com.google.gson.LongSerializationPolicyTest", "com.google.gson.internal.JavaVersionTest", "com.google.gson.functional.TreeTypeAdaptersTest", "com.google.gson.VersionExclusionStrategyTest", "com.google.gson.functional.JsonParserTest", "com.google.gson.JsonPrimitiveTest", "com.google.gson.functional.InterfaceTest", "com.google.gson.functional.SerializedNameTest", "com.google.gson.stream.JsonReaderTest", "com.google.gson.functional.GsonVersionDiagnosticsTest", "com.google.gson.functional.JsonAdapterAnnotationOnFieldsTest", "com.google.gson.internal.reflect.UnsafeReflectionAccessorTest", "com.google.gson.functional.ArrayTest", "com.google.gson.internal.bind.JsonTreeReaderTest", "com.google.gson.DefaultInetAddressTypeAdapterTest", "com.google.gson.internal.GsonTypesTest", "com.google.gson.internal.bind.JsonElementReaderTest", "com.google.gson.functional.MoreSpecificTypeSerializationTest", "com.google.gson.functional.StringTest", "com.google.gson.functional.ExclusionStrategyFunctionalTest", "com.google.gson.functional.PrimitiveTest", "com.google.gson.functional.JavaUtilTest", "com.google.gson.functional.NullObjectAndFieldTest", "com.google.gson.internal.UnsafeAllocatorInstantiationTest", "com.google.gson.GsonBuilderTest", "com.google.gson.internal.bind.JsonTreeWriterTest", "com.google.gson.ParameterizedTypeTest", "com.google.gson.functional.RuntimeTypeAdapterFactoryFunctionalTest", "com.google.gson.functional.EscapingTest", "com.google.gson.functional.UncategorizedTest", "com.google.gson.functional.ParameterizedTypesTest", "com.google.gson.functional.JsonTreeTest", "com.google.gson.functional.VersioningTest", "com.google.gson.internal.LinkedTreeMapTest", "com.google.gson.functional.CustomSerializerTest", "com.google.gson.functional.MapAsArrayTypeAdapterTest", "com.google.gson.functional.RawSerializationTest", "com.google.gson.functional.ReadersWritersTest", "com.google.gson.ExposeAnnotationExclusionStrategyTest", "com.google.gson.MixedStreamTest", "com.google.gson.internal.bind.RecursiveTypesResolveTest", "com.google.gson.functional.PrintFormattingTest", "com.google.gson.internal.LazilyParsedNumberTest", "com.google.gson.JsonObjectTest", "com.google.gson.functional.StreamingTypeAdaptersTest", "com.google.gson.JavaSerializationTest", "com.google.gson.functional.ThrowableFunctionalTest", "com.google.gson.functional.JsonArrayTest", "com.google.gson.functional.ObjectTest", "com.google.gson.DefaultMapJsonSerializerTest", "com.google.gson.CommentsTest", "com.google.gson.functional.JsonAdapterSerializerDeserializerTest", "com.google.gson.JsonParserTest", "com.google.gson.GsonTypeAdapterTest", "com.google.gson.regression.JsonAdapterNullSafeTest"], "failed_tests": ["com.google.gson.DefaultDateTypeAdapterTest"], "skipped_tests": []}, "test_patch_result": {"passed_count": 94, "failed_count": 2, "skipped_count": 0, "passed_tests": ["com.google.gson.functional.FieldNamingTest", "com.google.gson.functional.InstanceCreatorTest", "com.google.gson.functional.CustomTypeAdaptersTest", "com.google.gson.JsonStreamParserTest", "com.google.gson.functional.PrimitiveCharacterTest", "com.google.gson.functional.DelegateTypeAdapterTest", "com.google.gson.stream.JsonWriterTest", "com.google.gson.metrics.PerformanceTest", "com.google.gson.stream.JsonReaderPathTest", "com.google.gson.functional.PrettyPrintingTest", "com.google.gson.functional.JsonAdapterAnnotationOnClassesTest", "com.google.gson.functional.TypeHierarchyAdapterTest", "com.google.gson.ObjectTypeAdapterTest", "com.google.gson.GenericArrayTypeTest", "com.google.gson.JsonArrayTest", "com.google.gson.functional.JavaUtilConcurrentAtomicTest", "com.google.gson.JsonNullTest", "com.google.gson.functional.SecurityTest", "com.google.gson.functional.MapTest", "com.google.gson.functional.EnumTest", "com.google.gson.functional.ConcurrencyTest", "com.google.gson.functional.CustomDeserializerTest", "com.google.gson.functional.TypeAdapterPrecedenceTest", "com.google.gson.internal.GsonBuildConfigTest", "com.google.gson.reflect.TypeTokenTest", "com.google.gson.internal.LinkedHashTreeMapTest", "com.google.gson.functional.InheritanceTest", "com.google.gson.InnerClassExclusionStrategyTest", "com.google.gson.OverrideCoreTypeAdaptersTest", "com.google.gson.functional.CollectionTest", "com.google.gson.functional.LeniencyTest", "com.google.gson.functional.TypeVariableTest", "com.google.gson.GsonTest", "com.google.gson.functional.InternationalizationTest", "com.google.gson.functional.FieldExclusionTest", "com.google.gson.functional.DefaultTypeAdaptersTest", "com.google.gson.FieldAttributesTest", "com.google.gson.functional.CircularReferenceTest", "com.google.gson.functional.NamingPolicyTest", "com.google.gson.functional.ExposeFieldsTest", "com.google.gson.LongSerializationPolicyTest", "com.google.gson.internal.JavaVersionTest", "com.google.gson.functional.TreeTypeAdaptersTest", "com.google.gson.VersionExclusionStrategyTest", "com.google.gson.functional.JsonParserTest", "com.google.gson.JsonPrimitiveTest", "com.google.gson.functional.InterfaceTest", "com.google.gson.functional.SerializedNameTest", "com.google.gson.stream.JsonReaderTest", "com.google.gson.functional.GsonVersionDiagnosticsTest", "com.google.gson.functional.JsonAdapterAnnotationOnFieldsTest", "com.google.gson.internal.reflect.UnsafeReflectionAccessorTest", "com.google.gson.functional.ArrayTest", "com.google.gson.internal.bind.JsonTreeReaderTest", "com.google.gson.DefaultInetAddressTypeAdapterTest", "com.google.gson.internal.GsonTypesTest", "com.google.gson.internal.bind.JsonElementReaderTest", "com.google.gson.functional.MoreSpecificTypeSerializationTest", "com.google.gson.functional.StringTest", "com.google.gson.functional.ExclusionStrategyFunctionalTest", "com.google.gson.functional.PrimitiveTest", "com.google.gson.functional.JavaUtilTest", "com.google.gson.functional.NullObjectAndFieldTest", "com.google.gson.internal.UnsafeAllocatorInstantiationTest", "com.google.gson.GsonBuilderTest", "com.google.gson.internal.bind.JsonTreeWriterTest", "com.google.gson.ParameterizedTypeTest", "com.google.gson.functional.RuntimeTypeAdapterFactoryFunctionalTest", "com.google.gson.functional.EscapingTest", "com.google.gson.functional.UncategorizedTest", "com.google.gson.functional.ParameterizedTypesTest", "com.google.gson.functional.JsonTreeTest", "com.google.gson.functional.VersioningTest", "com.google.gson.internal.LinkedTreeMapTest", "com.google.gson.functional.CustomSerializerTest", "com.google.gson.functional.MapAsArrayTypeAdapterTest", "com.google.gson.functional.RawSerializationTest", "com.google.gson.functional.ReadersWritersTest", "com.google.gson.ExposeAnnotationExclusionStrategyTest", "com.google.gson.MixedStreamTest", "com.google.gson.internal.bind.RecursiveTypesResolveTest", "com.google.gson.functional.PrintFormattingTest", "com.google.gson.internal.LazilyParsedNumberTest", "com.google.gson.JsonObjectTest", "com.google.gson.functional.StreamingTypeAdaptersTest", "com.google.gson.JavaSerializationTest", "com.google.gson.functional.ThrowableFunctionalTest", "com.google.gson.functional.JsonArrayTest", "com.google.gson.functional.ObjectTest", "com.google.gson.DefaultMapJsonSerializerTest", "com.google.gson.CommentsTest", "com.google.gson.JsonParserTest", "com.google.gson.GsonTypeAdapterTest", "com.google.gson.regression.JsonAdapterNullSafeTest"], "failed_tests": ["com.google.gson.DefaultDateTypeAdapterTest", "com.google.gson.functional.JsonAdapterSerializerDeserializerTest"], "skipped_tests": []}, "fix_patch_result": {"passed_count": 95, "failed_count": 1, "skipped_count": 0, "passed_tests": ["com.google.gson.functional.FieldNamingTest", "com.google.gson.functional.InstanceCreatorTest", "com.google.gson.functional.CustomTypeAdaptersTest", "com.google.gson.JsonStreamParserTest", "com.google.gson.functional.PrimitiveCharacterTest", "com.google.gson.functional.DelegateTypeAdapterTest", "com.google.gson.stream.JsonWriterTest", "com.google.gson.metrics.PerformanceTest", "com.google.gson.stream.JsonReaderPathTest", "com.google.gson.functional.PrettyPrintingTest", "com.google.gson.functional.JsonAdapterAnnotationOnClassesTest", "com.google.gson.functional.TypeHierarchyAdapterTest", "com.google.gson.ObjectTypeAdapterTest", "com.google.gson.GenericArrayTypeTest", "com.google.gson.JsonArrayTest", "com.google.gson.functional.JavaUtilConcurrentAtomicTest", "com.google.gson.JsonNullTest", "com.google.gson.functional.SecurityTest", "com.google.gson.functional.MapTest", "com.google.gson.functional.EnumTest", "com.google.gson.functional.ConcurrencyTest", "com.google.gson.functional.CustomDeserializerTest", "com.google.gson.functional.TypeAdapterPrecedenceTest", "com.google.gson.internal.GsonBuildConfigTest", "com.google.gson.reflect.TypeTokenTest", "com.google.gson.internal.LinkedHashTreeMapTest", "com.google.gson.functional.InheritanceTest", "com.google.gson.InnerClassExclusionStrategyTest", "com.google.gson.OverrideCoreTypeAdaptersTest", "com.google.gson.functional.CollectionTest", "com.google.gson.functional.LeniencyTest", "com.google.gson.functional.TypeVariableTest", "com.google.gson.GsonTest", "com.google.gson.functional.InternationalizationTest", "com.google.gson.functional.FieldExclusionTest", "com.google.gson.functional.DefaultTypeAdaptersTest", "com.google.gson.FieldAttributesTest", "com.google.gson.functional.CircularReferenceTest", "com.google.gson.functional.NamingPolicyTest", "com.google.gson.functional.ExposeFieldsTest", "com.google.gson.LongSerializationPolicyTest", "com.google.gson.internal.JavaVersionTest", "com.google.gson.functional.TreeTypeAdaptersTest", "com.google.gson.VersionExclusionStrategyTest", "com.google.gson.functional.JsonParserTest", "com.google.gson.JsonPrimitiveTest", "com.google.gson.functional.InterfaceTest", "com.google.gson.functional.SerializedNameTest", "com.google.gson.stream.JsonReaderTest", "com.google.gson.functional.GsonVersionDiagnosticsTest", "com.google.gson.functional.JsonAdapterAnnotationOnFieldsTest", "com.google.gson.internal.reflect.UnsafeReflectionAccessorTest", "com.google.gson.functional.ArrayTest", "com.google.gson.internal.bind.JsonTreeReaderTest", "com.google.gson.DefaultInetAddressTypeAdapterTest", "com.google.gson.internal.GsonTypesTest", "com.google.gson.internal.bind.JsonElementReaderTest", "com.google.gson.functional.MoreSpecificTypeSerializationTest", "com.google.gson.functional.StringTest", "com.google.gson.functional.ExclusionStrategyFunctionalTest", "com.google.gson.functional.PrimitiveTest", "com.google.gson.functional.JavaUtilTest", "com.google.gson.functional.NullObjectAndFieldTest", "com.google.gson.internal.UnsafeAllocatorInstantiationTest", "com.google.gson.GsonBuilderTest", "com.google.gson.internal.bind.JsonTreeWriterTest", "com.google.gson.ParameterizedTypeTest", "com.google.gson.functional.RuntimeTypeAdapterFactoryFunctionalTest", "com.google.gson.functional.EscapingTest", "com.google.gson.functional.UncategorizedTest", "com.google.gson.functional.ParameterizedTypesTest", "com.google.gson.functional.JsonTreeTest", "com.google.gson.functional.VersioningTest", "com.google.gson.internal.LinkedTreeMapTest", "com.google.gson.functional.CustomSerializerTest", "com.google.gson.functional.MapAsArrayTypeAdapterTest", "com.google.gson.functional.RawSerializationTest", "com.google.gson.functional.ReadersWritersTest", "com.google.gson.ExposeAnnotationExclusionStrategyTest", "com.google.gson.MixedStreamTest", "com.google.gson.internal.bind.RecursiveTypesResolveTest", "com.google.gson.functional.PrintFormattingTest", "com.google.gson.internal.LazilyParsedNumberTest", "com.google.gson.JsonObjectTest", "com.google.gson.functional.StreamingTypeAdaptersTest", "com.google.gson.JavaSerializationTest", "com.google.gson.functional.ThrowableFunctionalTest", "com.google.gson.functional.JsonArrayTest", "com.google.gson.functional.ObjectTest", "com.google.gson.DefaultMapJsonSerializerTest", "com.google.gson.CommentsTest", "com.google.gson.functional.JsonAdapterSerializerDeserializerTest", "com.google.gson.JsonParserTest", "com.google.gson.GsonTypeAdapterTest", "com.google.gson.regression.JsonAdapterNullSafeTest"], "failed_tests": ["com.google.gson.DefaultDateTypeAdapterTest"], "skipped_tests": []}, "instance_id": "google__gson-1555"}
{"org": "google", "repo": "gson", "number": 1391, "state": "closed", "title": "Fix issue with recursive type variable protections to fix #1390", "body": "When a type variable is referenced multiple times it needs to resolve to the same value.  Previously, the second attempt would abort resolution early in order to protect against infinite recursion.\r\n\r\nNOTE: I could use some scrutiny on this as I don't fully understand the implications of all the code branches.  This commit does resolve the issue but stylistically I'm not really sold on breaking out of the while loop in order to capture the final result for subsequent resolution attempts.\r\n\r\nFixes #1390 \r\n", "base": {"label": "google:master", "ref": "master", "sha": "3f4ac29f9112799a7374a99b18acabd0232ff075"}, "resolved_issues": [{"number": 1390, "title": "Recursive TypeVariable resolution results in ClassCastException when type var is referenced multiple times", "body": "The recursive type variable resolution protections put into place in Gson 2.8.2 to fix #1128 does not work if a TypeVariable is referenced multiple times.\r\n\r\nExample failing code:\r\n```\r\n    enum TestEnum { ONE, TWO, THREE }\r\n\r\n    private static class TestEnumSetCollection extends SetCollection<TestEnum> {}\r\n\r\n    private static class SetCollection<T> extends BaseCollection<T, Set<T>> {}\r\n\r\n    private static class BaseCollection<U, C extends Collection<U>>\r\n    {\r\n        public C collection;\r\n    }\r\n```\r\n\r\nWhen used with the following code to unmarshal\r\n```\r\nTestEnumSetCollection withSet = gson.fromJson(\"{\\\"collection\\\":[\\\"ONE\\\",\\\"THREE\\\"]}\", TestEnumSetCollection.class);\r\n```\r\nThe enum values are unmarshaled as `String` instances instead of as `TestEnum` instances, causing `ClassCastException` to be raised at runtime.  This is due to the fact that the `visitedTypeVariables` map receives an entry for `T`, resolves it properly, and then upon subsequent attempt to resolve `T` fails, since the `visitedTypeVariables` set indicates that `T` has already been resolved."}], "fix_patch": "diff --git a/gson/src/main/java/com/google/gson/internal/$Gson$Types.java b/gson/src/main/java/com/google/gson/internal/$Gson$Types.java\nindex adea605f59..53985bc30a 100644\n--- a/gson/src/main/java/com/google/gson/internal/$Gson$Types.java\n+++ b/gson/src/main/java/com/google/gson/internal/$Gson$Types.java\n@@ -25,7 +25,12 @@\n import java.lang.reflect.Type;\n import java.lang.reflect.TypeVariable;\n import java.lang.reflect.WildcardType;\n-import java.util.*;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Properties;\n \n import static com.google.gson.internal.$Gson$Preconditions.checkArgument;\n import static com.google.gson.internal.$Gson$Preconditions.checkNotNull;\n@@ -334,52 +339,61 @@ public static Type[] getMapKeyAndValueTypes(Type context, Class<?> contextRawTyp\n   }\n \n   public static Type resolve(Type context, Class<?> contextRawType, Type toResolve) {\n-    return resolve(context, contextRawType, toResolve, new HashSet<TypeVariable>());\n+    return resolve(context, contextRawType, toResolve, new HashMap<TypeVariable, Type>());\n   }\n \n   private static Type resolve(Type context, Class<?> contextRawType, Type toResolve,\n-                              Collection<TypeVariable> visitedTypeVariables) {\n+                              Map<TypeVariable, Type> visitedTypeVariables) {\n     // this implementation is made a little more complicated in an attempt to avoid object-creation\n+    TypeVariable resolving = null;\n     while (true) {\n       if (toResolve instanceof TypeVariable) {\n         TypeVariable<?> typeVariable = (TypeVariable<?>) toResolve;\n-        if (visitedTypeVariables.contains(typeVariable)) {\n+        Type previouslyResolved = visitedTypeVariables.get(typeVariable);\n+        if (previouslyResolved != null) {\n           // cannot reduce due to infinite recursion\n-          return toResolve;\n-        } else {\n-          visitedTypeVariables.add(typeVariable);\n+          return (previouslyResolved == Void.TYPE) ? toResolve : previouslyResolved;\n         }\n+\n+        // Insert a placeholder to mark the fact that we are in the process of resolving this type\n+        visitedTypeVariables.put(typeVariable, Void.TYPE);\n+        if (resolving == null) {\n+          resolving = typeVariable;\n+        }\n+\n         toResolve = resolveTypeVariable(context, contextRawType, typeVariable);\n         if (toResolve == typeVariable) {\n-          return toResolve;\n+          break;\n         }\n \n       } else if (toResolve instanceof Class && ((Class<?>) toResolve).isArray()) {\n         Class<?> original = (Class<?>) toResolve;\n         Type componentType = original.getComponentType();\n         Type newComponentType = resolve(context, contextRawType, componentType, visitedTypeVariables);\n-        return componentType == newComponentType\n+        toResolve = equal(componentType, newComponentType)\n             ? original\n             : arrayOf(newComponentType);\n+        break;\n \n       } else if (toResolve instanceof GenericArrayType) {\n         GenericArrayType original = (GenericArrayType) toResolve;\n         Type componentType = original.getGenericComponentType();\n         Type newComponentType = resolve(context, contextRawType, componentType, visitedTypeVariables);\n-        return componentType == newComponentType\n+        toResolve = equal(componentType, newComponentType)\n             ? original\n             : arrayOf(newComponentType);\n+        break;\n \n       } else if (toResolve instanceof ParameterizedType) {\n         ParameterizedType original = (ParameterizedType) toResolve;\n         Type ownerType = original.getOwnerType();\n         Type newOwnerType = resolve(context, contextRawType, ownerType, visitedTypeVariables);\n-        boolean changed = newOwnerType != ownerType;\n+        boolean changed = !equal(newOwnerType, ownerType);\n \n         Type[] args = original.getActualTypeArguments();\n         for (int t = 0, length = args.length; t < length; t++) {\n           Type resolvedTypeArgument = resolve(context, contextRawType, args[t], visitedTypeVariables);\n-          if (resolvedTypeArgument != args[t]) {\n+          if (!equal(resolvedTypeArgument, args[t])) {\n             if (!changed) {\n               args = args.clone();\n               changed = true;\n@@ -388,9 +402,10 @@ private static Type resolve(Type context, Class<?> contextRawType, Type toResolv\n           }\n         }\n \n-        return changed\n+        toResolve = changed\n             ? newParameterizedTypeWithOwner(newOwnerType, original.getRawType(), args)\n             : original;\n+        break;\n \n       } else if (toResolve instanceof WildcardType) {\n         WildcardType original = (WildcardType) toResolve;\n@@ -400,20 +415,28 @@ private static Type resolve(Type context, Class<?> contextRawType, Type toResolv\n         if (originalLowerBound.length == 1) {\n           Type lowerBound = resolve(context, contextRawType, originalLowerBound[0], visitedTypeVariables);\n           if (lowerBound != originalLowerBound[0]) {\n-            return supertypeOf(lowerBound);\n+            toResolve = supertypeOf(lowerBound);\n+            break;\n           }\n         } else if (originalUpperBound.length == 1) {\n           Type upperBound = resolve(context, contextRawType, originalUpperBound[0], visitedTypeVariables);\n           if (upperBound != originalUpperBound[0]) {\n-            return subtypeOf(upperBound);\n+            toResolve = subtypeOf(upperBound);\n+            break;\n           }\n         }\n-        return original;\n+        toResolve = original;\n+        break;\n \n       } else {\n-        return toResolve;\n+        break;\n       }\n     }\n+    // ensure that any in-process resolution gets updated with the final result\n+    if (resolving != null) {\n+      visitedTypeVariables.put(resolving, toResolve);\n+    }\n+    return toResolve;\n   }\n \n   static Type resolveTypeVariable(Type context, Class<?> contextRawType, TypeVariable<?> unknown) {\n", "test_patch": "diff --git a/gson/src/test/java/com/google/gson/functional/ReusedTypeVariablesFullyResolveTest.java b/gson/src/test/java/com/google/gson/functional/ReusedTypeVariablesFullyResolveTest.java\nnew file mode 100644\nindex 0000000000..e3ddd840e9\n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/functional/ReusedTypeVariablesFullyResolveTest.java\n@@ -0,0 +1,54 @@\n+package com.google.gson.functional;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Set;\n+\n+import static org.junit.Assert.*;\n+\n+/**\n+ * This test covers the scenario described in #1390 where a type variable needs to be used\n+ * by a type definition multiple times.  Both type variable references should resolve to the\n+ * same underlying concrete type.\n+ */\n+public class ReusedTypeVariablesFullyResolveTest {\n+\n+    private Gson gson;\n+\n+    @Before\n+    public void setUp() {\n+        gson = new GsonBuilder().create();\n+    }\n+\n+    @SuppressWarnings(\"ConstantConditions\") // The instances were being unmarshaled as Strings instead of TestEnums\n+    @Test\n+    public void testGenericsPreservation() {\n+        TestEnumSetCollection withSet = gson.fromJson(\"{\\\"collection\\\":[\\\"ONE\\\",\\\"THREE\\\"]}\", TestEnumSetCollection.class);\n+        Iterator<TestEnum> iterator = withSet.collection.iterator();\n+        assertNotNull(withSet);\n+        assertNotNull(withSet.collection);\n+        assertEquals(2, withSet.collection.size());\n+        TestEnum first = iterator.next();\n+        TestEnum second = iterator.next();\n+\n+        assertTrue(first instanceof TestEnum);\n+        assertTrue(second instanceof TestEnum);\n+    }\n+\n+    enum TestEnum { ONE, TWO, THREE }\n+\n+    private static class TestEnumSetCollection extends SetCollection<TestEnum> {}\n+\n+    private static class SetCollection<T> extends BaseCollection<T, Set<T>> {}\n+\n+    private static class BaseCollection<U, C extends Collection<U>>\n+    {\n+        public C collection;\n+    }\n+\n+}\n", "fixed_tests": {"com.google.gson.functional.ReusedTypeVariablesFullyResolveTest": {"run": "NONE", "test": "FAIL", "fix": "PASS"}}, "p2p_tests": {"com.google.gson.stream.JsonReaderTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.FieldNamingTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.GsonVersionDiagnosticsTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.InstanceCreatorTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.JsonAdapterAnnotationOnFieldsTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.CustomTypeAdaptersTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.JsonStreamParserTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.internal.reflect.UnsafeReflectionAccessorTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.PrimitiveCharacterTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.ArrayTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.internal.bind.JsonTreeReaderTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.DefaultInetAddressTypeAdapterTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.internal.GsonTypesTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.DelegateTypeAdapterTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.internal.bind.JsonElementReaderTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.MoreSpecificTypeSerializationTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.stream.JsonWriterTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.StringTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.metrics.PerformanceTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.stream.JsonReaderPathTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.PrettyPrintingTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.ExclusionStrategyFunctionalTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.JsonAdapterAnnotationOnClassesTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.TypeHierarchyAdapterTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.ObjectTypeAdapterTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.PrimitiveTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.GenericArrayTypeTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.JsonArrayTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.JavaUtilTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.JavaUtilConcurrentAtomicTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.NullObjectAndFieldTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.JsonNullTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.internal.UnsafeAllocatorInstantiationTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.SecurityTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.MapTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.EnumTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.GsonBuilderTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.ConcurrencyTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.internal.bind.JsonTreeWriterTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.ParameterizedTypeTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.RuntimeTypeAdapterFactoryFunctionalTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.EscapingTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.CustomDeserializerTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.TypeAdapterPrecedenceTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.internal.GsonBuildConfigTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.reflect.TypeTokenTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.internal.LinkedHashTreeMapTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.InheritanceTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.UncategorizedTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.ParameterizedTypesTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.InnerClassExclusionStrategyTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.JsonTreeTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.VersioningTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.OverrideCoreTypeAdaptersTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.internal.LinkedTreeMapTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.CollectionTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.LeniencyTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.CustomSerializerTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.TypeVariableTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.MapAsArrayTypeAdapterTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.RawSerializationTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.GsonTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.ReadersWritersTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.ExposeAnnotationExclusionStrategyTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.InternationalizationTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.MixedStreamTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.internal.bind.RecursiveTypesResolveTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.FieldExclusionTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.PrintFormattingTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.internal.LazilyParsedNumberTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.JsonObjectTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.StreamingTypeAdaptersTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.JavaSerializationTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.ThrowableFunctionalTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.JsonArrayTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.DefaultTypeAdaptersTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.ObjectTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.FieldAttributesTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.CircularReferenceTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.NamingPolicyTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.ExposeFieldsTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.LongSerializationPolicyTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.DefaultMapJsonSerializerTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.CommentsTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.internal.JavaVersionTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.TreeTypeAdaptersTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.VersionExclusionStrategyTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.JsonParserTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.JsonPrimitiveTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.JsonAdapterSerializerDeserializerTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.InterfaceTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.JsonParserTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.GsonTypeAdapterTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.regression.JsonAdapterNullSafeTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.SerializedNameTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}}, "f2p_tests": {"com.google.gson.functional.ReusedTypeVariablesFullyResolveTest": {"run": "NONE", "test": "FAIL", "fix": "PASS"}}, "s2p_tests": {}, "n2p_tests": {}, "run_result": {"passed_count": 95, "failed_count": 1, "skipped_count": 0, "passed_tests": ["com.google.gson.functional.FieldNamingTest", "com.google.gson.functional.InstanceCreatorTest", "com.google.gson.functional.CustomTypeAdaptersTest", "com.google.gson.JsonStreamParserTest", "com.google.gson.functional.PrimitiveCharacterTest", "com.google.gson.functional.DelegateTypeAdapterTest", "com.google.gson.stream.JsonWriterTest", "com.google.gson.metrics.PerformanceTest", "com.google.gson.stream.JsonReaderPathTest", "com.google.gson.functional.PrettyPrintingTest", "com.google.gson.functional.JsonAdapterAnnotationOnClassesTest", "com.google.gson.functional.TypeHierarchyAdapterTest", "com.google.gson.ObjectTypeAdapterTest", "com.google.gson.GenericArrayTypeTest", "com.google.gson.JsonArrayTest", "com.google.gson.functional.JavaUtilConcurrentAtomicTest", "com.google.gson.JsonNullTest", "com.google.gson.functional.SecurityTest", "com.google.gson.functional.MapTest", "com.google.gson.functional.EnumTest", "com.google.gson.functional.ConcurrencyTest", "com.google.gson.functional.CustomDeserializerTest", "com.google.gson.functional.TypeAdapterPrecedenceTest", "com.google.gson.internal.GsonBuildConfigTest", "com.google.gson.reflect.TypeTokenTest", "com.google.gson.internal.LinkedHashTreeMapTest", "com.google.gson.functional.InheritanceTest", "com.google.gson.InnerClassExclusionStrategyTest", "com.google.gson.OverrideCoreTypeAdaptersTest", "com.google.gson.functional.CollectionTest", "com.google.gson.functional.LeniencyTest", "com.google.gson.functional.TypeVariableTest", "com.google.gson.GsonTest", "com.google.gson.functional.InternationalizationTest", "com.google.gson.functional.FieldExclusionTest", "com.google.gson.functional.DefaultTypeAdaptersTest", "com.google.gson.FieldAttributesTest", "com.google.gson.functional.CircularReferenceTest", "com.google.gson.functional.NamingPolicyTest", "com.google.gson.functional.ExposeFieldsTest", "com.google.gson.LongSerializationPolicyTest", "com.google.gson.internal.JavaVersionTest", "com.google.gson.functional.TreeTypeAdaptersTest", "com.google.gson.VersionExclusionStrategyTest", "com.google.gson.functional.JsonParserTest", "com.google.gson.JsonPrimitiveTest", "com.google.gson.functional.InterfaceTest", "com.google.gson.functional.SerializedNameTest", "com.google.gson.stream.JsonReaderTest", "com.google.gson.functional.GsonVersionDiagnosticsTest", "com.google.gson.functional.JsonAdapterAnnotationOnFieldsTest", "com.google.gson.internal.reflect.UnsafeReflectionAccessorTest", "com.google.gson.functional.ArrayTest", "com.google.gson.internal.bind.JsonTreeReaderTest", "com.google.gson.DefaultInetAddressTypeAdapterTest", "com.google.gson.internal.GsonTypesTest", "com.google.gson.internal.bind.JsonElementReaderTest", "com.google.gson.functional.MoreSpecificTypeSerializationTest", "com.google.gson.functional.StringTest", "com.google.gson.functional.ExclusionStrategyFunctionalTest", "com.google.gson.functional.PrimitiveTest", "com.google.gson.functional.JavaUtilTest", "com.google.gson.functional.NullObjectAndFieldTest", "com.google.gson.internal.UnsafeAllocatorInstantiationTest", "com.google.gson.GsonBuilderTest", "com.google.gson.internal.bind.JsonTreeWriterTest", "com.google.gson.ParameterizedTypeTest", "com.google.gson.functional.RuntimeTypeAdapterFactoryFunctionalTest", "com.google.gson.functional.EscapingTest", "com.google.gson.functional.UncategorizedTest", "com.google.gson.functional.ParameterizedTypesTest", "com.google.gson.functional.JsonTreeTest", "com.google.gson.functional.VersioningTest", "com.google.gson.internal.LinkedTreeMapTest", "com.google.gson.functional.CustomSerializerTest", "com.google.gson.functional.MapAsArrayTypeAdapterTest", "com.google.gson.functional.RawSerializationTest", "com.google.gson.functional.ReadersWritersTest", "com.google.gson.ExposeAnnotationExclusionStrategyTest", "com.google.gson.MixedStreamTest", "com.google.gson.internal.bind.RecursiveTypesResolveTest", "com.google.gson.functional.PrintFormattingTest", "com.google.gson.internal.LazilyParsedNumberTest", "com.google.gson.JsonObjectTest", "com.google.gson.functional.StreamingTypeAdaptersTest", "com.google.gson.JavaSerializationTest", "com.google.gson.functional.ThrowableFunctionalTest", "com.google.gson.functional.JsonArrayTest", "com.google.gson.functional.ObjectTest", "com.google.gson.DefaultMapJsonSerializerTest", "com.google.gson.CommentsTest", "com.google.gson.functional.JsonAdapterSerializerDeserializerTest", "com.google.gson.JsonParserTest", "com.google.gson.GsonTypeAdapterTest", "com.google.gson.regression.JsonAdapterNullSafeTest"], "failed_tests": ["com.google.gson.DefaultDateTypeAdapterTest"], "skipped_tests": []}, "test_patch_result": {"passed_count": 95, "failed_count": 2, "skipped_count": 0, "passed_tests": ["com.google.gson.functional.FieldNamingTest", "com.google.gson.functional.InstanceCreatorTest", "com.google.gson.functional.CustomTypeAdaptersTest", "com.google.gson.JsonStreamParserTest", "com.google.gson.functional.PrimitiveCharacterTest", "com.google.gson.functional.DelegateTypeAdapterTest", "com.google.gson.stream.JsonWriterTest", "com.google.gson.metrics.PerformanceTest", "com.google.gson.stream.JsonReaderPathTest", "com.google.gson.functional.PrettyPrintingTest", "com.google.gson.functional.JsonAdapterAnnotationOnClassesTest", "com.google.gson.functional.TypeHierarchyAdapterTest", "com.google.gson.ObjectTypeAdapterTest", "com.google.gson.GenericArrayTypeTest", "com.google.gson.JsonArrayTest", "com.google.gson.functional.JavaUtilConcurrentAtomicTest", "com.google.gson.JsonNullTest", "com.google.gson.functional.SecurityTest", "com.google.gson.functional.MapTest", "com.google.gson.functional.EnumTest", "com.google.gson.functional.ConcurrencyTest", "com.google.gson.functional.CustomDeserializerTest", "com.google.gson.functional.TypeAdapterPrecedenceTest", "com.google.gson.internal.GsonBuildConfigTest", "com.google.gson.reflect.TypeTokenTest", "com.google.gson.internal.LinkedHashTreeMapTest", "com.google.gson.functional.InheritanceTest", "com.google.gson.InnerClassExclusionStrategyTest", "com.google.gson.OverrideCoreTypeAdaptersTest", "com.google.gson.functional.CollectionTest", "com.google.gson.functional.LeniencyTest", "com.google.gson.functional.TypeVariableTest", "com.google.gson.GsonTest", "com.google.gson.functional.InternationalizationTest", "com.google.gson.functional.FieldExclusionTest", "com.google.gson.functional.DefaultTypeAdaptersTest", "com.google.gson.FieldAttributesTest", "com.google.gson.functional.CircularReferenceTest", "com.google.gson.functional.NamingPolicyTest", "com.google.gson.functional.ExposeFieldsTest", "com.google.gson.LongSerializationPolicyTest", "com.google.gson.internal.JavaVersionTest", "com.google.gson.functional.TreeTypeAdaptersTest", "com.google.gson.VersionExclusionStrategyTest", "com.google.gson.functional.JsonParserTest", "com.google.gson.JsonPrimitiveTest", "com.google.gson.functional.InterfaceTest", "com.google.gson.functional.SerializedNameTest", "com.google.gson.stream.JsonReaderTest", "com.google.gson.functional.GsonVersionDiagnosticsTest", "com.google.gson.functional.JsonAdapterAnnotationOnFieldsTest", "com.google.gson.internal.reflect.UnsafeReflectionAccessorTest", "com.google.gson.functional.ArrayTest", "com.google.gson.internal.bind.JsonTreeReaderTest", "com.google.gson.DefaultInetAddressTypeAdapterTest", "com.google.gson.internal.GsonTypesTest", "com.google.gson.internal.bind.JsonElementReaderTest", "com.google.gson.functional.MoreSpecificTypeSerializationTest", "com.google.gson.functional.StringTest", "com.google.gson.functional.ExclusionStrategyFunctionalTest", "com.google.gson.functional.PrimitiveTest", "com.google.gson.functional.JavaUtilTest", "com.google.gson.functional.NullObjectAndFieldTest", "com.google.gson.internal.UnsafeAllocatorInstantiationTest", "com.google.gson.GsonBuilderTest", "com.google.gson.internal.bind.JsonTreeWriterTest", "com.google.gson.ParameterizedTypeTest", "com.google.gson.functional.RuntimeTypeAdapterFactoryFunctionalTest", "com.google.gson.functional.EscapingTest", "com.google.gson.functional.UncategorizedTest", "com.google.gson.functional.ParameterizedTypesTest", "com.google.gson.functional.JsonTreeTest", "com.google.gson.functional.VersioningTest", "com.google.gson.internal.LinkedTreeMapTest", "com.google.gson.functional.CustomSerializerTest", "com.google.gson.functional.MapAsArrayTypeAdapterTest", "com.google.gson.functional.RawSerializationTest", "com.google.gson.functional.ReadersWritersTest", "com.google.gson.ExposeAnnotationExclusionStrategyTest", "com.google.gson.MixedStreamTest", "com.google.gson.internal.bind.RecursiveTypesResolveTest", "com.google.gson.functional.PrintFormattingTest", "com.google.gson.internal.LazilyParsedNumberTest", "com.google.gson.JsonObjectTest", "com.google.gson.functional.StreamingTypeAdaptersTest", "com.google.gson.JavaSerializationTest", "com.google.gson.functional.ThrowableFunctionalTest", "com.google.gson.functional.JsonArrayTest", "com.google.gson.functional.ObjectTest", "com.google.gson.DefaultMapJsonSerializerTest", "com.google.gson.CommentsTest", "com.google.gson.functional.JsonAdapterSerializerDeserializerTest", "com.google.gson.JsonParserTest", "com.google.gson.GsonTypeAdapterTest", "com.google.gson.regression.JsonAdapterNullSafeTest"], "failed_tests": ["com.google.gson.DefaultDateTypeAdapterTest", "com.google.gson.functional.ReusedTypeVariablesFullyResolveTest"], "skipped_tests": []}, "fix_patch_result": {"passed_count": 96, "failed_count": 1, "skipped_count": 0, "passed_tests": ["com.google.gson.functional.FieldNamingTest", "com.google.gson.functional.InstanceCreatorTest", "com.google.gson.functional.CustomTypeAdaptersTest", "com.google.gson.JsonStreamParserTest", "com.google.gson.functional.PrimitiveCharacterTest", "com.google.gson.functional.DelegateTypeAdapterTest", "com.google.gson.stream.JsonWriterTest", "com.google.gson.metrics.PerformanceTest", "com.google.gson.stream.JsonReaderPathTest", "com.google.gson.functional.PrettyPrintingTest", "com.google.gson.functional.JsonAdapterAnnotationOnClassesTest", "com.google.gson.functional.TypeHierarchyAdapterTest", "com.google.gson.ObjectTypeAdapterTest", "com.google.gson.GenericArrayTypeTest", "com.google.gson.JsonArrayTest", "com.google.gson.functional.JavaUtilConcurrentAtomicTest", "com.google.gson.JsonNullTest", "com.google.gson.functional.SecurityTest", "com.google.gson.functional.MapTest", "com.google.gson.functional.EnumTest", "com.google.gson.functional.ConcurrencyTest", "com.google.gson.functional.CustomDeserializerTest", "com.google.gson.functional.TypeAdapterPrecedenceTest", "com.google.gson.internal.GsonBuildConfigTest", "com.google.gson.reflect.TypeTokenTest", "com.google.gson.internal.LinkedHashTreeMapTest", "com.google.gson.functional.InheritanceTest", "com.google.gson.InnerClassExclusionStrategyTest", "com.google.gson.OverrideCoreTypeAdaptersTest", "com.google.gson.functional.CollectionTest", "com.google.gson.functional.LeniencyTest", "com.google.gson.functional.TypeVariableTest", "com.google.gson.GsonTest", "com.google.gson.functional.InternationalizationTest", "com.google.gson.functional.FieldExclusionTest", "com.google.gson.functional.DefaultTypeAdaptersTest", "com.google.gson.FieldAttributesTest", "com.google.gson.functional.CircularReferenceTest", "com.google.gson.functional.NamingPolicyTest", "com.google.gson.functional.ExposeFieldsTest", "com.google.gson.LongSerializationPolicyTest", "com.google.gson.internal.JavaVersionTest", "com.google.gson.functional.TreeTypeAdaptersTest", "com.google.gson.VersionExclusionStrategyTest", "com.google.gson.functional.JsonParserTest", "com.google.gson.JsonPrimitiveTest", "com.google.gson.functional.InterfaceTest", "com.google.gson.functional.SerializedNameTest", "com.google.gson.stream.JsonReaderTest", "com.google.gson.functional.GsonVersionDiagnosticsTest", "com.google.gson.functional.JsonAdapterAnnotationOnFieldsTest", "com.google.gson.internal.reflect.UnsafeReflectionAccessorTest", "com.google.gson.functional.ArrayTest", "com.google.gson.internal.bind.JsonTreeReaderTest", "com.google.gson.DefaultInetAddressTypeAdapterTest", "com.google.gson.internal.GsonTypesTest", "com.google.gson.internal.bind.JsonElementReaderTest", "com.google.gson.functional.MoreSpecificTypeSerializationTest", "com.google.gson.functional.StringTest", "com.google.gson.functional.ExclusionStrategyFunctionalTest", "com.google.gson.functional.PrimitiveTest", "com.google.gson.functional.JavaUtilTest", "com.google.gson.functional.ReusedTypeVariablesFullyResolveTest", "com.google.gson.functional.NullObjectAndFieldTest", "com.google.gson.internal.UnsafeAllocatorInstantiationTest", "com.google.gson.GsonBuilderTest", "com.google.gson.internal.bind.JsonTreeWriterTest", "com.google.gson.ParameterizedTypeTest", "com.google.gson.functional.RuntimeTypeAdapterFactoryFunctionalTest", "com.google.gson.functional.EscapingTest", "com.google.gson.functional.UncategorizedTest", "com.google.gson.functional.ParameterizedTypesTest", "com.google.gson.functional.JsonTreeTest", "com.google.gson.functional.VersioningTest", "com.google.gson.internal.LinkedTreeMapTest", "com.google.gson.functional.CustomSerializerTest", "com.google.gson.functional.MapAsArrayTypeAdapterTest", "com.google.gson.functional.RawSerializationTest", "com.google.gson.functional.ReadersWritersTest", "com.google.gson.ExposeAnnotationExclusionStrategyTest", "com.google.gson.MixedStreamTest", "com.google.gson.internal.bind.RecursiveTypesResolveTest", "com.google.gson.functional.PrintFormattingTest", "com.google.gson.internal.LazilyParsedNumberTest", "com.google.gson.JsonObjectTest", "com.google.gson.functional.StreamingTypeAdaptersTest", "com.google.gson.JavaSerializationTest", "com.google.gson.functional.ThrowableFunctionalTest", "com.google.gson.functional.JsonArrayTest", "com.google.gson.functional.ObjectTest", "com.google.gson.DefaultMapJsonSerializerTest", "com.google.gson.CommentsTest", "com.google.gson.functional.JsonAdapterSerializerDeserializerTest", "com.google.gson.JsonParserTest", "com.google.gson.GsonTypeAdapterTest", "com.google.gson.regression.JsonAdapterNullSafeTest"], "failed_tests": ["com.google.gson.DefaultDateTypeAdapterTest"], "skipped_tests": []}, "instance_id": "google__gson-1391"}
{"org": "google", "repo": "gson", "number": 1093, "state": "closed", "title": "value(double) can write NaN and infinite values when lenient, as value(Number) does", "body": "Fixes #1090.", "base": {"label": "google:master", "ref": "master", "sha": "0aaef0fd1bb1b9729543dc40168adfb829eb75a4"}, "resolved_issues": [{"number": 1090, "title": "JsonWriter#value(java.lang.Number) can be lenient, but JsonWriter#value(double) can't,", "body": "In lenient mode, JsonWriter#value(java.lang.Number) can write pseudo-numeric values like `NaN`, `Infinity`, `-Infinity`:\r\n```java\r\n    if (!lenient\r\n        && (string.equals(\"-Infinity\") || string.equals(\"Infinity\") || string.equals(\"NaN\"))) {\r\n      throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\r\n    }\r\n```\r\n\r\nBut JsonWriter#value(double) behaves in different way: \r\n```java\r\n    if (Double.isNaN(value) || Double.isInfinite(value)) {\r\n      throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\r\n    }\r\n```\r\n\r\nSo, while working with streaming, it's impossible to write semi-numeric value without boxing a double (e. g. `out.value((Number) Double.valueOf(Double.NaN))`).\r\n\r\nI think, this should be possible, because boxing gives worse performance."}], "fix_patch": "diff --git a/gson/src/main/java/com/google/gson/stream/JsonWriter.java b/gson/src/main/java/com/google/gson/stream/JsonWriter.java\nindex e2fc19611d..8148816c2f 100644\n--- a/gson/src/main/java/com/google/gson/stream/JsonWriter.java\n+++ b/gson/src/main/java/com/google/gson/stream/JsonWriter.java\n@@ -491,10 +491,10 @@ public JsonWriter value(Boolean value) throws IOException {\n    * @return this writer.\n    */\n   public JsonWriter value(double value) throws IOException {\n-    if (Double.isNaN(value) || Double.isInfinite(value)) {\n+    writeDeferredName();\n+    if (!lenient && (Double.isNaN(value) || Double.isInfinite(value))) {\n       throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n     }\n-    writeDeferredName();\n     beforeValue();\n     out.append(Double.toString(value));\n     return this;\n", "test_patch": "diff --git a/gson/src/test/java/com/google/gson/stream/JsonWriterTest.java b/gson/src/test/java/com/google/gson/stream/JsonWriterTest.java\nindex 34dc914022..2bcec173ca 100644\n--- a/gson/src/test/java/com/google/gson/stream/JsonWriterTest.java\n+++ b/gson/src/test/java/com/google/gson/stream/JsonWriterTest.java\n@@ -16,11 +16,12 @@\n \n package com.google.gson.stream;\n \n+import junit.framework.TestCase;\n+\n import java.io.IOException;\n import java.io.StringWriter;\n import java.math.BigDecimal;\n import java.math.BigInteger;\n-import junit.framework.TestCase;\n \n @SuppressWarnings(\"resource\")\n public final class JsonWriterTest extends TestCase {\n@@ -213,6 +214,30 @@ public void testNonFiniteBoxedDoubles() throws IOException {\n     }\n   }\n \n+  public void testNonFiniteDoublesWhenLenient() throws IOException {\n+    StringWriter stringWriter = new StringWriter();\n+    JsonWriter jsonWriter = new JsonWriter(stringWriter);\n+    jsonWriter.setLenient(true);\n+    jsonWriter.beginArray();\n+    jsonWriter.value(Double.NaN);\n+    jsonWriter.value(Double.NEGATIVE_INFINITY);\n+    jsonWriter.value(Double.POSITIVE_INFINITY);\n+    jsonWriter.endArray();\n+    assertEquals(\"[NaN,-Infinity,Infinity]\", stringWriter.toString());\n+  }\n+\n+  public void testNonFiniteBoxedDoublesWhenLenient() throws IOException {\n+    StringWriter stringWriter = new StringWriter();\n+    JsonWriter jsonWriter = new JsonWriter(stringWriter);\n+    jsonWriter.setLenient(true);\n+    jsonWriter.beginArray();\n+    jsonWriter.value(Double.valueOf(Double.NaN));\n+    jsonWriter.value(Double.valueOf(Double.NEGATIVE_INFINITY));\n+    jsonWriter.value(Double.valueOf(Double.POSITIVE_INFINITY));\n+    jsonWriter.endArray();\n+    assertEquals(\"[NaN,-Infinity,Infinity]\", stringWriter.toString());\n+  }\n+\n   public void testDoubles() throws IOException {\n     StringWriter stringWriter = new StringWriter();\n     JsonWriter jsonWriter = new JsonWriter(stringWriter);\n", "fixed_tests": {"com.google.gson.stream.JsonWriterTest": {"run": "PASS", "test": "FAIL", "fix": "PASS"}}, "p2p_tests": {"com.google.gson.stream.JsonReaderTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.FieldNamingTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.InstanceCreatorTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.JsonAdapterAnnotationOnFieldsTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.CustomTypeAdaptersTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.JsonStreamParserTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.PrimitiveCharacterTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.ArrayTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.internal.bind.JsonTreeReaderTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.DefaultInetAddressTypeAdapterTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.internal.GsonTypesTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.DelegateTypeAdapterTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.internal.bind.JsonElementReaderTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.MoreSpecificTypeSerializationTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.StringTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.metrics.PerformanceTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.stream.JsonReaderPathTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.PrettyPrintingTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.ExclusionStrategyFunctionalTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.JsonAdapterAnnotationOnClassesTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.TypeHierarchyAdapterTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.ObjectTypeAdapterTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.PrimitiveTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.GenericArrayTypeTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.JsonArrayTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.JavaUtilTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.JavaUtilConcurrentAtomicTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.NullObjectAndFieldTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.JsonNullTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.internal.UnsafeAllocatorInstantiationTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.SecurityTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.MapTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.EnumTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.GsonBuilderTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.ConcurrencyTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.internal.bind.JsonTreeWriterTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.ParameterizedTypeTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.RuntimeTypeAdapterFactoryFunctionalTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.EscapingTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.CustomDeserializerTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.TypeAdapterPrecedenceTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.reflect.TypeTokenTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.internal.LinkedHashTreeMapTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.InheritanceTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.UncategorizedTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.ParameterizedTypesTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.InnerClassExclusionStrategyTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.JsonTreeTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.VersioningTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.OverrideCoreTypeAdaptersTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.internal.LinkedTreeMapTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.CollectionTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.LeniencyTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.CustomSerializerTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.TypeVariableTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.MapAsArrayTypeAdapterTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.RawSerializationTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.GsonTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.ReadersWritersTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.ExposeAnnotationExclusionStrategyTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.InternationalizationTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.MixedStreamTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.internal.bind.RecursiveTypesResolveTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.FieldExclusionTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.PrintFormattingTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.internal.LazilyParsedNumberTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.JsonObjectTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.StreamingTypeAdaptersTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.JavaSerializationTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.JsonArrayTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.FieldAttributesTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.CircularReferenceTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.NamingPolicyTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.ExposeFieldsTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.LongSerializationPolicyTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.DefaultMapJsonSerializerTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.CommentsTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.TreeTypeAdaptersTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.VersionExclusionStrategyTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.JsonParserTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.JsonPrimitiveTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.JsonAdapterSerializerDeserializerTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.InterfaceTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.JsonParserTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.GsonTypeAdapterTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.regression.JsonAdapterNullSafeTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}, "com.google.gson.functional.SerializedNameTest": {"run": "PASS", "test": "PASS", "fix": "PASS"}}, "f2p_tests": {"com.google.gson.stream.JsonWriterTest": {"run": "PASS", "test": "FAIL", "fix": "PASS"}}, "s2p_tests": {}, "n2p_tests": {}, "run_result": {"passed_count": 88, "failed_count": 3, "skipped_count": 0, "passed_tests": ["com.google.gson.functional.FieldNamingTest", "com.google.gson.functional.InstanceCreatorTest", "com.google.gson.functional.CustomTypeAdaptersTest", "com.google.gson.JsonStreamParserTest", "com.google.gson.functional.PrimitiveCharacterTest", "com.google.gson.functional.DelegateTypeAdapterTest", "com.google.gson.stream.JsonWriterTest", "com.google.gson.metrics.PerformanceTest", "com.google.gson.stream.JsonReaderPathTest", "com.google.gson.functional.PrettyPrintingTest", "com.google.gson.functional.JsonAdapterAnnotationOnClassesTest", "com.google.gson.functional.TypeHierarchyAdapterTest", "com.google.gson.ObjectTypeAdapterTest", "com.google.gson.GenericArrayTypeTest", "com.google.gson.JsonArrayTest", "com.google.gson.functional.JavaUtilConcurrentAtomicTest", "com.google.gson.JsonNullTest", "com.google.gson.functional.SecurityTest", "com.google.gson.functional.MapTest", "com.google.gson.functional.EnumTest", "com.google.gson.functional.ConcurrencyTest", "com.google.gson.functional.CustomDeserializerTest", "com.google.gson.functional.TypeAdapterPrecedenceTest", "com.google.gson.reflect.TypeTokenTest", "com.google.gson.internal.LinkedHashTreeMapTest", "com.google.gson.functional.InheritanceTest", "com.google.gson.InnerClassExclusionStrategyTest", "com.google.gson.OverrideCoreTypeAdaptersTest", "com.google.gson.functional.CollectionTest", "com.google.gson.functional.LeniencyTest", "com.google.gson.functional.TypeVariableTest", "com.google.gson.GsonTest", "com.google.gson.functional.InternationalizationTest", "com.google.gson.functional.FieldExclusionTest", "com.google.gson.FieldAttributesTest", "com.google.gson.functional.CircularReferenceTest", "com.google.gson.functional.NamingPolicyTest", "com.google.gson.functional.ExposeFieldsTest", "com.google.gson.LongSerializationPolicyTest", "com.google.gson.functional.TreeTypeAdaptersTest", "com.google.gson.VersionExclusionStrategyTest", "com.google.gson.functional.JsonParserTest", "com.google.gson.JsonPrimitiveTest", "com.google.gson.functional.InterfaceTest", "com.google.gson.functional.SerializedNameTest", "com.google.gson.stream.JsonReaderTest", "com.google.gson.functional.JsonAdapterAnnotationOnFieldsTest", "com.google.gson.functional.ArrayTest", "com.google.gson.internal.bind.JsonTreeReaderTest", "com.google.gson.DefaultInetAddressTypeAdapterTest", "com.google.gson.internal.GsonTypesTest", "com.google.gson.internal.bind.JsonElementReaderTest", "com.google.gson.functional.MoreSpecificTypeSerializationTest", "com.google.gson.functional.StringTest", "com.google.gson.functional.ExclusionStrategyFunctionalTest", "com.google.gson.functional.PrimitiveTest", "com.google.gson.functional.JavaUtilTest", "com.google.gson.functional.NullObjectAndFieldTest", "com.google.gson.internal.UnsafeAllocatorInstantiationTest", "com.google.gson.GsonBuilderTest", "com.google.gson.internal.bind.JsonTreeWriterTest", "com.google.gson.ParameterizedTypeTest", "com.google.gson.functional.RuntimeTypeAdapterFactoryFunctionalTest", "com.google.gson.functional.EscapingTest", "com.google.gson.functional.UncategorizedTest", "com.google.gson.functional.ParameterizedTypesTest", "com.google.gson.functional.JsonTreeTest", "com.google.gson.functional.VersioningTest", "com.google.gson.internal.LinkedTreeMapTest", "com.google.gson.functional.CustomSerializerTest", "com.google.gson.functional.MapAsArrayTypeAdapterTest", "com.google.gson.functional.RawSerializationTest", "com.google.gson.functional.ReadersWritersTest", "com.google.gson.ExposeAnnotationExclusionStrategyTest", "com.google.gson.MixedStreamTest", "com.google.gson.internal.bind.RecursiveTypesResolveTest", "com.google.gson.functional.PrintFormattingTest", "com.google.gson.internal.LazilyParsedNumberTest", "com.google.gson.JsonObjectTest", "com.google.gson.functional.StreamingTypeAdaptersTest", "com.google.gson.JavaSerializationTest", "com.google.gson.functional.JsonArrayTest", "com.google.gson.DefaultMapJsonSerializerTest", "com.google.gson.CommentsTest", "com.google.gson.functional.JsonAdapterSerializerDeserializerTest", "com.google.gson.JsonParserTest", "com.google.gson.GsonTypeAdapterTest", "com.google.gson.regression.JsonAdapterNullSafeTest"], "failed_tests": ["com.google.gson.functional.DefaultTypeAdaptersTest", "com.google.gson.DefaultDateTypeAdapterTest", "com.google.gson.functional.ObjectTest"], "skipped_tests": []}, "test_patch_result": {"passed_count": 87, "failed_count": 4, "skipped_count": 0, "passed_tests": ["com.google.gson.functional.FieldNamingTest", "com.google.gson.functional.InstanceCreatorTest", "com.google.gson.functional.CustomTypeAdaptersTest", "com.google.gson.JsonStreamParserTest", "com.google.gson.functional.PrimitiveCharacterTest", "com.google.gson.functional.DelegateTypeAdapterTest", "com.google.gson.metrics.PerformanceTest", "com.google.gson.stream.JsonReaderPathTest", "com.google.gson.functional.PrettyPrintingTest", "com.google.gson.functional.JsonAdapterAnnotationOnClassesTest", "com.google.gson.functional.TypeHierarchyAdapterTest", "com.google.gson.ObjectTypeAdapterTest", "com.google.gson.GenericArrayTypeTest", "com.google.gson.JsonArrayTest", "com.google.gson.functional.JavaUtilConcurrentAtomicTest", "com.google.gson.JsonNullTest", "com.google.gson.functional.SecurityTest", "com.google.gson.functional.MapTest", "com.google.gson.functional.EnumTest", "com.google.gson.functional.ConcurrencyTest", "com.google.gson.functional.CustomDeserializerTest", "com.google.gson.functional.TypeAdapterPrecedenceTest", "com.google.gson.reflect.TypeTokenTest", "com.google.gson.internal.LinkedHashTreeMapTest", "com.google.gson.functional.InheritanceTest", "com.google.gson.InnerClassExclusionStrategyTest", "com.google.gson.OverrideCoreTypeAdaptersTest", "com.google.gson.functional.CollectionTest", "com.google.gson.functional.LeniencyTest", "com.google.gson.functional.TypeVariableTest", "com.google.gson.GsonTest", "com.google.gson.functional.InternationalizationTest", "com.google.gson.functional.FieldExclusionTest", "com.google.gson.FieldAttributesTest", "com.google.gson.functional.CircularReferenceTest", "com.google.gson.functional.NamingPolicyTest", "com.google.gson.functional.ExposeFieldsTest", "com.google.gson.LongSerializationPolicyTest", "com.google.gson.functional.TreeTypeAdaptersTest", "com.google.gson.VersionExclusionStrategyTest", "com.google.gson.functional.JsonParserTest", "com.google.gson.JsonPrimitiveTest", "com.google.gson.functional.InterfaceTest", "com.google.gson.functional.SerializedNameTest", "com.google.gson.stream.JsonReaderTest", "com.google.gson.functional.JsonAdapterAnnotationOnFieldsTest", "com.google.gson.functional.ArrayTest", "com.google.gson.internal.bind.JsonTreeReaderTest", "com.google.gson.DefaultInetAddressTypeAdapterTest", "com.google.gson.internal.GsonTypesTest", "com.google.gson.internal.bind.JsonElementReaderTest", "com.google.gson.functional.MoreSpecificTypeSerializationTest", "com.google.gson.functional.StringTest", "com.google.gson.functional.ExclusionStrategyFunctionalTest", "com.google.gson.functional.PrimitiveTest", "com.google.gson.functional.JavaUtilTest", "com.google.gson.functional.NullObjectAndFieldTest", "com.google.gson.internal.UnsafeAllocatorInstantiationTest", "com.google.gson.GsonBuilderTest", "com.google.gson.internal.bind.JsonTreeWriterTest", "com.google.gson.ParameterizedTypeTest", "com.google.gson.functional.RuntimeTypeAdapterFactoryFunctionalTest", "com.google.gson.functional.EscapingTest", "com.google.gson.functional.UncategorizedTest", "com.google.gson.functional.ParameterizedTypesTest", "com.google.gson.functional.JsonTreeTest", "com.google.gson.functional.VersioningTest", "com.google.gson.internal.LinkedTreeMapTest", "com.google.gson.functional.CustomSerializerTest", "com.google.gson.functional.MapAsArrayTypeAdapterTest", "com.google.gson.functional.RawSerializationTest", "com.google.gson.functional.ReadersWritersTest", "com.google.gson.ExposeAnnotationExclusionStrategyTest", "com.google.gson.MixedStreamTest", "com.google.gson.internal.bind.RecursiveTypesResolveTest", "com.google.gson.functional.PrintFormattingTest", "com.google.gson.internal.LazilyParsedNumberTest", "com.google.gson.JsonObjectTest", "com.google.gson.functional.StreamingTypeAdaptersTest", "com.google.gson.JavaSerializationTest", "com.google.gson.functional.JsonArrayTest", "com.google.gson.DefaultMapJsonSerializerTest", "com.google.gson.CommentsTest", "com.google.gson.functional.JsonAdapterSerializerDeserializerTest", "com.google.gson.JsonParserTest", "com.google.gson.GsonTypeAdapterTest", "com.google.gson.regression.JsonAdapterNullSafeTest"], "failed_tests": ["com.google.gson.stream.JsonWriterTest", "com.google.gson.functional.DefaultTypeAdaptersTest", "com.google.gson.DefaultDateTypeAdapterTest", "com.google.gson.functional.ObjectTest"], "skipped_tests": []}, "fix_patch_result": {"passed_count": 88, "failed_count": 3, "skipped_count": 0, "passed_tests": ["com.google.gson.functional.FieldNamingTest", "com.google.gson.functional.InstanceCreatorTest", "com.google.gson.functional.CustomTypeAdaptersTest", "com.google.gson.JsonStreamParserTest", "com.google.gson.functional.PrimitiveCharacterTest", "com.google.gson.functional.DelegateTypeAdapterTest", "com.google.gson.stream.JsonWriterTest", "com.google.gson.metrics.PerformanceTest", "com.google.gson.stream.JsonReaderPathTest", "com.google.gson.functional.PrettyPrintingTest", "com.google.gson.functional.JsonAdapterAnnotationOnClassesTest", "com.google.gson.functional.TypeHierarchyAdapterTest", "com.google.gson.ObjectTypeAdapterTest", "com.google.gson.GenericArrayTypeTest", "com.google.gson.JsonArrayTest", "com.google.gson.functional.JavaUtilConcurrentAtomicTest", "com.google.gson.JsonNullTest", "com.google.gson.functional.SecurityTest", "com.google.gson.functional.MapTest", "com.google.gson.functional.EnumTest", "com.google.gson.functional.ConcurrencyTest", "com.google.gson.functional.CustomDeserializerTest", "com.google.gson.functional.TypeAdapterPrecedenceTest", "com.google.gson.reflect.TypeTokenTest", "com.google.gson.internal.LinkedHashTreeMapTest", "com.google.gson.functional.InheritanceTest", "com.google.gson.InnerClassExclusionStrategyTest", "com.google.gson.OverrideCoreTypeAdaptersTest", "com.google.gson.functional.CollectionTest", "com.google.gson.functional.LeniencyTest", "com.google.gson.functional.TypeVariableTest", "com.google.gson.GsonTest", "com.google.gson.functional.InternationalizationTest", "com.google.gson.functional.FieldExclusionTest", "com.google.gson.FieldAttributesTest", "com.google.gson.functional.CircularReferenceTest", "com.google.gson.functional.NamingPolicyTest", "com.google.gson.functional.ExposeFieldsTest", "com.google.gson.LongSerializationPolicyTest", "com.google.gson.functional.TreeTypeAdaptersTest", "com.google.gson.VersionExclusionStrategyTest", "com.google.gson.functional.JsonParserTest", "com.google.gson.JsonPrimitiveTest", "com.google.gson.functional.InterfaceTest", "com.google.gson.functional.SerializedNameTest", "com.google.gson.stream.JsonReaderTest", "com.google.gson.functional.JsonAdapterAnnotationOnFieldsTest", "com.google.gson.functional.ArrayTest", "com.google.gson.internal.bind.JsonTreeReaderTest", "com.google.gson.DefaultInetAddressTypeAdapterTest", "com.google.gson.internal.GsonTypesTest", "com.google.gson.internal.bind.JsonElementReaderTest", "com.google.gson.functional.MoreSpecificTypeSerializationTest", "com.google.gson.functional.StringTest", "com.google.gson.functional.ExclusionStrategyFunctionalTest", "com.google.gson.functional.PrimitiveTest", "com.google.gson.functional.JavaUtilTest", "com.google.gson.functional.NullObjectAndFieldTest", "com.google.gson.internal.UnsafeAllocatorInstantiationTest", "com.google.gson.GsonBuilderTest", "com.google.gson.internal.bind.JsonTreeWriterTest", "com.google.gson.ParameterizedTypeTest", "com.google.gson.functional.RuntimeTypeAdapterFactoryFunctionalTest", "com.google.gson.functional.EscapingTest", "com.google.gson.functional.UncategorizedTest", "com.google.gson.functional.ParameterizedTypesTest", "com.google.gson.functional.JsonTreeTest", "com.google.gson.functional.VersioningTest", "com.google.gson.internal.LinkedTreeMapTest", "com.google.gson.functional.CustomSerializerTest", "com.google.gson.functional.MapAsArrayTypeAdapterTest", "com.google.gson.functional.RawSerializationTest", "com.google.gson.functional.ReadersWritersTest", "com.google.gson.ExposeAnnotationExclusionStrategyTest", "com.google.gson.MixedStreamTest", "com.google.gson.internal.bind.RecursiveTypesResolveTest", "com.google.gson.functional.PrintFormattingTest", "com.google.gson.internal.LazilyParsedNumberTest", "com.google.gson.JsonObjectTest", "com.google.gson.functional.StreamingTypeAdaptersTest", "com.google.gson.JavaSerializationTest", "com.google.gson.functional.JsonArrayTest", "com.google.gson.DefaultMapJsonSerializerTest", "com.google.gson.CommentsTest", "com.google.gson.functional.JsonAdapterSerializerDeserializerTest", "com.google.gson.JsonParserTest", "com.google.gson.GsonTypeAdapterTest", "com.google.gson.regression.JsonAdapterNullSafeTest"], "failed_tests": ["com.google.gson.functional.DefaultTypeAdaptersTest", "com.google.gson.DefaultDateTypeAdapterTest", "com.google.gson.functional.ObjectTest"], "skipped_tests": []}, "instance_id": "google__gson-1093"}
